   1               		.file	"RP6ControlLib.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	INT0_event_DUMMY
  12               	INT0_event_DUMMY:
  13               	.LFB11:
  14               		.file 1 "RP6Lib/RP6control/RP6ControlLib.c"
   1:RP6Lib/RP6control/RP6ControlLib.c **** /* ****************************************************************************
   2:RP6Lib/RP6control/RP6ControlLib.c ****  *                           _______________________
   3:RP6Lib/RP6control/RP6ControlLib.c ****  *                           \| RP6  ROBOT SYSTEM |/
   4:RP6Lib/RP6control/RP6ControlLib.c ****  *                            \_-_-_-_-_-_-_-_-_-_/             >>> RP6 CONTROL
   5:RP6Lib/RP6control/RP6ControlLib.c ****  * ----------------------------------------------------------------------------
   6:RP6Lib/RP6control/RP6ControlLib.c ****  * ------------------- [c]2006 / 2007 - AREXX ENGINEERING ---------------------
   7:RP6Lib/RP6control/RP6ControlLib.c ****  * -------------------------- http://www.arexx.com/ ---------------------------
   8:RP6Lib/RP6control/RP6ControlLib.c ****  * ****************************************************************************
   9:RP6Lib/RP6control/RP6ControlLib.c ****  * File: RP6ControlLib.c
  10:RP6Lib/RP6control/RP6ControlLib.c ****  * Version: 1.1
  11:RP6Lib/RP6control/RP6ControlLib.c ****  * Target: RP6 CONTROL - ATMEGA32 @16.00MHz
  12:RP6Lib/RP6control/RP6ControlLib.c ****  * Author(s): Dominik S. Herwald
  13:RP6Lib/RP6control/RP6ControlLib.c ****  * ****************************************************************************
  14:RP6Lib/RP6control/RP6ControlLib.c ****  * Description:
  15:RP6Lib/RP6control/RP6ControlLib.c ****  * The RP6 CONTROL M32 function Library.
  16:RP6Lib/RP6control/RP6ControlLib.c ****  *
  17:RP6Lib/RP6control/RP6ControlLib.c ****  * ****************************************************************************
  18:RP6Lib/RP6control/RP6ControlLib.c ****  * CHANGELOG AND LICENSING INFORMATION CAN BE FOUND AT THE END OF THIS FILE!
  19:RP6Lib/RP6control/RP6ControlLib.c ****  * ****************************************************************************
  20:RP6Lib/RP6control/RP6ControlLib.c ****  */
  21:RP6Lib/RP6control/RP6ControlLib.c **** 
  22:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
  23:RP6Lib/RP6control/RP6ControlLib.c **** // Includes:
  24:RP6Lib/RP6control/RP6ControlLib.c **** 
  25:RP6Lib/RP6control/RP6ControlLib.c **** #include "RP6ControlLib.h"
  26:RP6Lib/RP6control/RP6ControlLib.c **** 
  27:RP6Lib/RP6control/RP6ControlLib.c **** 
  28:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
  29:RP6Lib/RP6control/RP6ControlLib.c **** // External Interrupts and Event Handlers.
  30:RP6Lib/RP6control/RP6ControlLib.c **** // To allow common usage with the RP6Control library, you need to use
  31:RP6Lib/RP6control/RP6ControlLib.c **** // Event Handlers. 
  32:RP6Lib/RP6control/RP6ControlLib.c **** // Please make sure that you keep the Event Handler Functions as
  33:RP6Lib/RP6control/RP6ControlLib.c **** // short as possible! 
  34:RP6Lib/RP6control/RP6ControlLib.c **** // --> You usually don't need this stuff. 
  35:RP6Lib/RP6control/RP6ControlLib.c **** 
  36:RP6Lib/RP6control/RP6ControlLib.c **** void INT0_event_DUMMY(void){}
  15               		.loc 1 36 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21 0000 0895      		ret
  22               		.cfi_endproc
  23               	.LFE11:
  25               	.global	INT1_event_DUMMY
  27               	INT1_event_DUMMY:
  28               	.LFB14:
  37:RP6Lib/RP6control/RP6ControlLib.c **** static void (*INT0_eventHandler)(void) = INT0_event_DUMMY;
  38:RP6Lib/RP6control/RP6ControlLib.c **** void INT0_setEventHandler(void (*i0eventHandler)(void))
  39:RP6Lib/RP6control/RP6ControlLib.c **** {
  40:RP6Lib/RP6control/RP6ControlLib.c **** 	INT0_eventHandler = i0eventHandler;
  41:RP6Lib/RP6control/RP6ControlLib.c **** }
  42:RP6Lib/RP6control/RP6ControlLib.c **** 
  43:RP6Lib/RP6control/RP6ControlLib.c **** /**
  44:RP6Lib/RP6control/RP6ControlLib.c ****  * External Interrupt 0 ISR
  45:RP6Lib/RP6control/RP6ControlLib.c ****  */
  46:RP6Lib/RP6control/RP6ControlLib.c **** ISR (INT0_vect)
  47:RP6Lib/RP6control/RP6ControlLib.c **** {
  48:RP6Lib/RP6control/RP6ControlLib.c **** 	INT0_eventHandler();
  49:RP6Lib/RP6control/RP6ControlLib.c **** }
  50:RP6Lib/RP6control/RP6ControlLib.c **** 
  51:RP6Lib/RP6control/RP6ControlLib.c **** void INT1_event_DUMMY(void){}
  29               		.loc 1 51 0
  30               		.cfi_startproc
  31               	/* prologue: function */
  32               	/* frame size = 0 */
  33               	/* stack size = 0 */
  34               	.L__stack_usage = 0
  35 0002 0895      		ret
  36               		.cfi_endproc
  37               	.LFE14:
  39               	.global	INT2_event_DUMMY
  41               	INT2_event_DUMMY:
  42               	.LFB17:
  52:RP6Lib/RP6control/RP6ControlLib.c **** static void (*INT1_eventHandler)(void) = INT1_event_DUMMY;
  53:RP6Lib/RP6control/RP6ControlLib.c **** void INT1_setEventHandler(void (*i1eventHandler)(void))
  54:RP6Lib/RP6control/RP6ControlLib.c **** {
  55:RP6Lib/RP6control/RP6ControlLib.c **** 	INT1_eventHandler = i1eventHandler;
  56:RP6Lib/RP6control/RP6ControlLib.c **** }
  57:RP6Lib/RP6control/RP6ControlLib.c **** 
  58:RP6Lib/RP6control/RP6ControlLib.c **** /**
  59:RP6Lib/RP6control/RP6ControlLib.c ****  * External Interrupt 1 ISR
  60:RP6Lib/RP6control/RP6ControlLib.c ****  */
  61:RP6Lib/RP6control/RP6ControlLib.c **** ISR (INT1_vect)
  62:RP6Lib/RP6control/RP6ControlLib.c **** {
  63:RP6Lib/RP6control/RP6ControlLib.c **** 	INT1_eventHandler();
  64:RP6Lib/RP6control/RP6ControlLib.c **** }
  65:RP6Lib/RP6control/RP6ControlLib.c **** 
  66:RP6Lib/RP6control/RP6ControlLib.c **** void INT2_event_DUMMY(void){}
  43               		.loc 1 66 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49 0004 0895      		ret
  50               		.cfi_endproc
  51               	.LFE17:
  53               	.global	INT0_setEventHandler
  55               	INT0_setEventHandler:
  56               	.LFB12:
  39:RP6Lib/RP6control/RP6ControlLib.c **** 	INT0_eventHandler = i0eventHandler;
  57               		.loc 1 39 0
  58               		.cfi_startproc
  59               	.LVL0:
  60               	/* prologue: function */
  61               	/* frame size = 0 */
  62               	/* stack size = 0 */
  63               	.L__stack_usage = 0
  40:RP6Lib/RP6control/RP6ControlLib.c **** }
  64               		.loc 1 40 0
  65 0006 9093 0000 		sts INT0_eventHandler+1,r25
  66 000a 8093 0000 		sts INT0_eventHandler,r24
  67 000e 0895      		ret
  68               		.cfi_endproc
  69               	.LFE12:
  71               	.global	__vector_1
  73               	__vector_1:
  74               	.LFB13:
  47:RP6Lib/RP6control/RP6ControlLib.c **** 	INT0_eventHandler();
  75               		.loc 1 47 0
  76               		.cfi_startproc
  77 0010 1F92      		push r1
  78               	.LCFI0:
  79               		.cfi_def_cfa_offset 3
  80               		.cfi_offset 1, -2
  81 0012 0F92      		push r0
  82               	.LCFI1:
  83               		.cfi_def_cfa_offset 4
  84               		.cfi_offset 0, -3
  85 0014 0FB6      		in r0,__SREG__
  86 0016 0F92      		push r0
  87 0018 1124      		clr __zero_reg__
  88 001a 2F93      		push r18
  89               	.LCFI2:
  90               		.cfi_def_cfa_offset 5
  91               		.cfi_offset 18, -4
  92 001c 3F93      		push r19
  93               	.LCFI3:
  94               		.cfi_def_cfa_offset 6
  95               		.cfi_offset 19, -5
  96 001e 4F93      		push r20
  97               	.LCFI4:
  98               		.cfi_def_cfa_offset 7
  99               		.cfi_offset 20, -6
 100 0020 5F93      		push r21
 101               	.LCFI5:
 102               		.cfi_def_cfa_offset 8
 103               		.cfi_offset 21, -7
 104 0022 6F93      		push r22
 105               	.LCFI6:
 106               		.cfi_def_cfa_offset 9
 107               		.cfi_offset 22, -8
 108 0024 7F93      		push r23
 109               	.LCFI7:
 110               		.cfi_def_cfa_offset 10
 111               		.cfi_offset 23, -9
 112 0026 8F93      		push r24
 113               	.LCFI8:
 114               		.cfi_def_cfa_offset 11
 115               		.cfi_offset 24, -10
 116 0028 9F93      		push r25
 117               	.LCFI9:
 118               		.cfi_def_cfa_offset 12
 119               		.cfi_offset 25, -11
 120 002a AF93      		push r26
 121               	.LCFI10:
 122               		.cfi_def_cfa_offset 13
 123               		.cfi_offset 26, -12
 124 002c BF93      		push r27
 125               	.LCFI11:
 126               		.cfi_def_cfa_offset 14
 127               		.cfi_offset 27, -13
 128 002e EF93      		push r30
 129               	.LCFI12:
 130               		.cfi_def_cfa_offset 15
 131               		.cfi_offset 30, -14
 132 0030 FF93      		push r31
 133               	.LCFI13:
 134               		.cfi_def_cfa_offset 16
 135               		.cfi_offset 31, -15
 136               	/* prologue: Signal */
 137               	/* frame size = 0 */
 138               	/* stack size = 15 */
 139               	.L__stack_usage = 15
  48:RP6Lib/RP6control/RP6ControlLib.c **** }
 140               		.loc 1 48 0
 141 0032 E091 0000 		lds r30,INT0_eventHandler
 142 0036 F091 0000 		lds r31,INT0_eventHandler+1
 143 003a 0995      		icall
 144               	.LVL1:
 145               	/* epilogue start */
  49:RP6Lib/RP6control/RP6ControlLib.c **** 
 146               		.loc 1 49 0
 147 003c FF91      		pop r31
 148 003e EF91      		pop r30
 149 0040 BF91      		pop r27
 150 0042 AF91      		pop r26
 151 0044 9F91      		pop r25
 152 0046 8F91      		pop r24
 153 0048 7F91      		pop r23
 154 004a 6F91      		pop r22
 155 004c 5F91      		pop r21
 156 004e 4F91      		pop r20
 157 0050 3F91      		pop r19
 158 0052 2F91      		pop r18
 159 0054 0F90      		pop r0
 160 0056 0FBE      		out __SREG__,r0
 161 0058 0F90      		pop r0
 162 005a 1F90      		pop r1
 163 005c 1895      		reti
 164               		.cfi_endproc
 165               	.LFE13:
 167               	.global	INT1_setEventHandler
 169               	INT1_setEventHandler:
 170               	.LFB15:
  54:RP6Lib/RP6control/RP6ControlLib.c **** 	INT1_eventHandler = i1eventHandler;
 171               		.loc 1 54 0
 172               		.cfi_startproc
 173               	.LVL2:
 174               	/* prologue: function */
 175               	/* frame size = 0 */
 176               	/* stack size = 0 */
 177               	.L__stack_usage = 0
  55:RP6Lib/RP6control/RP6ControlLib.c **** }
 178               		.loc 1 55 0
 179 005e 9093 0000 		sts INT1_eventHandler+1,r25
 180 0062 8093 0000 		sts INT1_eventHandler,r24
 181 0066 0895      		ret
 182               		.cfi_endproc
 183               	.LFE15:
 185               	.global	__vector_2
 187               	__vector_2:
 188               	.LFB16:
  62:RP6Lib/RP6control/RP6ControlLib.c **** 	INT1_eventHandler();
 189               		.loc 1 62 0
 190               		.cfi_startproc
 191 0068 1F92      		push r1
 192               	.LCFI14:
 193               		.cfi_def_cfa_offset 3
 194               		.cfi_offset 1, -2
 195 006a 0F92      		push r0
 196               	.LCFI15:
 197               		.cfi_def_cfa_offset 4
 198               		.cfi_offset 0, -3
 199 006c 0FB6      		in r0,__SREG__
 200 006e 0F92      		push r0
 201 0070 1124      		clr __zero_reg__
 202 0072 2F93      		push r18
 203               	.LCFI16:
 204               		.cfi_def_cfa_offset 5
 205               		.cfi_offset 18, -4
 206 0074 3F93      		push r19
 207               	.LCFI17:
 208               		.cfi_def_cfa_offset 6
 209               		.cfi_offset 19, -5
 210 0076 4F93      		push r20
 211               	.LCFI18:
 212               		.cfi_def_cfa_offset 7
 213               		.cfi_offset 20, -6
 214 0078 5F93      		push r21
 215               	.LCFI19:
 216               		.cfi_def_cfa_offset 8
 217               		.cfi_offset 21, -7
 218 007a 6F93      		push r22
 219               	.LCFI20:
 220               		.cfi_def_cfa_offset 9
 221               		.cfi_offset 22, -8
 222 007c 7F93      		push r23
 223               	.LCFI21:
 224               		.cfi_def_cfa_offset 10
 225               		.cfi_offset 23, -9
 226 007e 8F93      		push r24
 227               	.LCFI22:
 228               		.cfi_def_cfa_offset 11
 229               		.cfi_offset 24, -10
 230 0080 9F93      		push r25
 231               	.LCFI23:
 232               		.cfi_def_cfa_offset 12
 233               		.cfi_offset 25, -11
 234 0082 AF93      		push r26
 235               	.LCFI24:
 236               		.cfi_def_cfa_offset 13
 237               		.cfi_offset 26, -12
 238 0084 BF93      		push r27
 239               	.LCFI25:
 240               		.cfi_def_cfa_offset 14
 241               		.cfi_offset 27, -13
 242 0086 EF93      		push r30
 243               	.LCFI26:
 244               		.cfi_def_cfa_offset 15
 245               		.cfi_offset 30, -14
 246 0088 FF93      		push r31
 247               	.LCFI27:
 248               		.cfi_def_cfa_offset 16
 249               		.cfi_offset 31, -15
 250               	/* prologue: Signal */
 251               	/* frame size = 0 */
 252               	/* stack size = 15 */
 253               	.L__stack_usage = 15
  63:RP6Lib/RP6control/RP6ControlLib.c **** }
 254               		.loc 1 63 0
 255 008a E091 0000 		lds r30,INT1_eventHandler
 256 008e F091 0000 		lds r31,INT1_eventHandler+1
 257 0092 0995      		icall
 258               	.LVL3:
 259               	/* epilogue start */
  64:RP6Lib/RP6control/RP6ControlLib.c **** 
 260               		.loc 1 64 0
 261 0094 FF91      		pop r31
 262 0096 EF91      		pop r30
 263 0098 BF91      		pop r27
 264 009a AF91      		pop r26
 265 009c 9F91      		pop r25
 266 009e 8F91      		pop r24
 267 00a0 7F91      		pop r23
 268 00a2 6F91      		pop r22
 269 00a4 5F91      		pop r21
 270 00a6 4F91      		pop r20
 271 00a8 3F91      		pop r19
 272 00aa 2F91      		pop r18
 273 00ac 0F90      		pop r0
 274 00ae 0FBE      		out __SREG__,r0
 275 00b0 0F90      		pop r0
 276 00b2 1F90      		pop r1
 277 00b4 1895      		reti
 278               		.cfi_endproc
 279               	.LFE16:
 281               	.global	INT2_setEventHandler
 283               	INT2_setEventHandler:
 284               	.LFB18:
  67:RP6Lib/RP6control/RP6ControlLib.c **** static void (*INT2_eventHandler)(void) = INT2_event_DUMMY;
  68:RP6Lib/RP6control/RP6ControlLib.c **** void INT2_setEventHandler(void (*i2eventHandler)(void))
  69:RP6Lib/RP6control/RP6ControlLib.c **** {
 285               		.loc 1 69 0
 286               		.cfi_startproc
 287               	.LVL4:
 288               	/* prologue: function */
 289               	/* frame size = 0 */
 290               	/* stack size = 0 */
 291               	.L__stack_usage = 0
  70:RP6Lib/RP6control/RP6ControlLib.c **** 	INT2_eventHandler = i2eventHandler;
 292               		.loc 1 70 0
 293 00b6 9093 0000 		sts INT2_eventHandler+1,r25
 294 00ba 8093 0000 		sts INT2_eventHandler,r24
 295 00be 0895      		ret
 296               		.cfi_endproc
 297               	.LFE18:
 299               	.global	__vector_3
 301               	__vector_3:
 302               	.LFB19:
  71:RP6Lib/RP6control/RP6ControlLib.c **** }
  72:RP6Lib/RP6control/RP6ControlLib.c **** 
  73:RP6Lib/RP6control/RP6ControlLib.c **** /**
  74:RP6Lib/RP6control/RP6ControlLib.c ****  * External Interrupt 2 ISR
  75:RP6Lib/RP6control/RP6ControlLib.c ****  */
  76:RP6Lib/RP6control/RP6ControlLib.c **** ISR (INT2_vect)
  77:RP6Lib/RP6control/RP6ControlLib.c **** {
 303               		.loc 1 77 0
 304               		.cfi_startproc
 305 00c0 1F92      		push r1
 306               	.LCFI28:
 307               		.cfi_def_cfa_offset 3
 308               		.cfi_offset 1, -2
 309 00c2 0F92      		push r0
 310               	.LCFI29:
 311               		.cfi_def_cfa_offset 4
 312               		.cfi_offset 0, -3
 313 00c4 0FB6      		in r0,__SREG__
 314 00c6 0F92      		push r0
 315 00c8 1124      		clr __zero_reg__
 316 00ca 2F93      		push r18
 317               	.LCFI30:
 318               		.cfi_def_cfa_offset 5
 319               		.cfi_offset 18, -4
 320 00cc 3F93      		push r19
 321               	.LCFI31:
 322               		.cfi_def_cfa_offset 6
 323               		.cfi_offset 19, -5
 324 00ce 4F93      		push r20
 325               	.LCFI32:
 326               		.cfi_def_cfa_offset 7
 327               		.cfi_offset 20, -6
 328 00d0 5F93      		push r21
 329               	.LCFI33:
 330               		.cfi_def_cfa_offset 8
 331               		.cfi_offset 21, -7
 332 00d2 6F93      		push r22
 333               	.LCFI34:
 334               		.cfi_def_cfa_offset 9
 335               		.cfi_offset 22, -8
 336 00d4 7F93      		push r23
 337               	.LCFI35:
 338               		.cfi_def_cfa_offset 10
 339               		.cfi_offset 23, -9
 340 00d6 8F93      		push r24
 341               	.LCFI36:
 342               		.cfi_def_cfa_offset 11
 343               		.cfi_offset 24, -10
 344 00d8 9F93      		push r25
 345               	.LCFI37:
 346               		.cfi_def_cfa_offset 12
 347               		.cfi_offset 25, -11
 348 00da AF93      		push r26
 349               	.LCFI38:
 350               		.cfi_def_cfa_offset 13
 351               		.cfi_offset 26, -12
 352 00dc BF93      		push r27
 353               	.LCFI39:
 354               		.cfi_def_cfa_offset 14
 355               		.cfi_offset 27, -13
 356 00de EF93      		push r30
 357               	.LCFI40:
 358               		.cfi_def_cfa_offset 15
 359               		.cfi_offset 30, -14
 360 00e0 FF93      		push r31
 361               	.LCFI41:
 362               		.cfi_def_cfa_offset 16
 363               		.cfi_offset 31, -15
 364               	/* prologue: Signal */
 365               	/* frame size = 0 */
 366               	/* stack size = 15 */
 367               	.L__stack_usage = 15
  78:RP6Lib/RP6control/RP6ControlLib.c **** 	INT2_eventHandler();
 368               		.loc 1 78 0
 369 00e2 E091 0000 		lds r30,INT2_eventHandler
 370 00e6 F091 0000 		lds r31,INT2_eventHandler+1
 371 00ea 0995      		icall
 372               	.LVL5:
 373               	/* epilogue start */
  79:RP6Lib/RP6control/RP6ControlLib.c **** }
 374               		.loc 1 79 0
 375 00ec FF91      		pop r31
 376 00ee EF91      		pop r30
 377 00f0 BF91      		pop r27
 378 00f2 AF91      		pop r26
 379 00f4 9F91      		pop r25
 380 00f6 8F91      		pop r24
 381 00f8 7F91      		pop r23
 382 00fa 6F91      		pop r22
 383 00fc 5F91      		pop r21
 384 00fe 4F91      		pop r20
 385 0100 3F91      		pop r19
 386 0102 2F91      		pop r18
 387 0104 0F90      		pop r0
 388 0106 0FBE      		out __SREG__,r0
 389 0108 0F90      		pop r0
 390 010a 1F90      		pop r1
 391 010c 1895      		reti
 392               		.cfi_endproc
 393               	.LFE19:
 395               	.global	readADC
 397               	readADC:
 398               	.LFB20:
  80:RP6Lib/RP6control/RP6ControlLib.c **** 
  81:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
  82:RP6Lib/RP6control/RP6ControlLib.c **** // ADC:
  83:RP6Lib/RP6control/RP6ControlLib.c **** 
  84:RP6Lib/RP6control/RP6ControlLib.c **** /**
  85:RP6Lib/RP6control/RP6ControlLib.c ****  * Read ADC channel (10 bit -> result is an integer from 0 to 1023).
  86:RP6Lib/RP6control/RP6ControlLib.c ****  * The channels (ADC_BAT etc.) are defined in the RP6Control.h file.
  87:RP6Lib/RP6control/RP6ControlLib.c ****  *
  88:RP6Lib/RP6control/RP6ControlLib.c ****  * This is a blocking function, which means it waits until the conversion
  89:RP6Lib/RP6control/RP6ControlLib.c ****  * is complete. 
  90:RP6Lib/RP6control/RP6ControlLib.c ****  *
  91:RP6Lib/RP6control/RP6ControlLib.c ****  */
  92:RP6Lib/RP6control/RP6ControlLib.c **** uint16_t readADC(uint8_t channel)
  93:RP6Lib/RP6control/RP6ControlLib.c **** {
 399               		.loc 1 93 0
 400               		.cfi_startproc
 401               	.LVL6:
 402               	/* prologue: function */
 403               	/* frame size = 0 */
 404               	/* stack size = 0 */
 405               	.L__stack_usage = 0
  94:RP6Lib/RP6control/RP6ControlLib.c **** 	if((ADCSRA & (1<<ADSC))) return 0; // check if ADC is buisy...
 406               		.loc 1 94 0
 407 010e 3699      		sbic 0x6,6
 408 0110 00C0      		rjmp .L14
 409               	.LVL7:
 410               	.LBB12:
 411               	.LBB13:
  95:RP6Lib/RP6control/RP6ControlLib.c **** 	ADMUX = (1<<REFS0) | (0<<REFS1) | (channel<<MUX0);
 412               		.loc 1 95 0
 413 0112 8064      		ori r24,lo8(64)
 414               	.LVL8:
 415 0114 87B9      		out 0x7,r24
  96:RP6Lib/RP6control/RP6ControlLib.c **** 	ADCSRA = (0<<ADIE) | (1<<ADSC) | (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADIF);
 416               		.loc 1 96 0
 417 0116 86ED      		ldi r24,lo8(-42)
 418 0118 86B9      		out 0x6,r24
 419               	.L13:
  97:RP6Lib/RP6control/RP6ControlLib.c **** 	while ((ADCSRA & (1<<ADSC))); 
 420               		.loc 1 97 0
 421 011a 3699      		sbic 0x6,6
 422 011c 00C0      		rjmp .L13
  98:RP6Lib/RP6control/RP6ControlLib.c **** 	ADCSRA |= (1<<ADIF);
 423               		.loc 1 98 0
 424 011e 349A      		sbi 0x6,4
  99:RP6Lib/RP6control/RP6ControlLib.c **** 	return ADC;
 425               		.loc 1 99 0
 426 0120 84B1      		in r24,0x4
 427 0122 95B1      		in r25,0x4+1
 428 0124 0895      		ret
 429               	.LVL9:
 430               	.L14:
 431               	.LBE13:
 432               	.LBE12:
  94:RP6Lib/RP6control/RP6ControlLib.c **** 	ADMUX = (1<<REFS0) | (0<<REFS1) | (channel<<MUX0);
 433               		.loc 1 94 0
 434 0126 80E0      		ldi r24,0
 435 0128 90E0      		ldi r25,0
 436               	.LVL10:
 100:RP6Lib/RP6control/RP6ControlLib.c **** }
 437               		.loc 1 100 0
 438 012a 0895      		ret
 439               		.cfi_endproc
 440               	.LFE20:
 442               	.global	writeSPI
 444               	writeSPI:
 445               	.LFB21:
 101:RP6Lib/RP6control/RP6ControlLib.c **** 
 102:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 103:RP6Lib/RP6control/RP6ControlLib.c **** // Hardware SPI Interface:
 104:RP6Lib/RP6control/RP6ControlLib.c **** 
 105:RP6Lib/RP6control/RP6ControlLib.c **** /**
 106:RP6Lib/RP6control/RP6ControlLib.c ****  * Writes a single Databyte to the SPI Interface.
 107:RP6Lib/RP6control/RP6ControlLib.c ****  */
 108:RP6Lib/RP6control/RP6ControlLib.c **** void writeSPI(uint8_t data) 
 109:RP6Lib/RP6control/RP6ControlLib.c **** {     
 446               		.loc 1 109 0
 447               		.cfi_startproc
 448               	.LVL11:
 449               	/* prologue: function */
 450               	/* frame size = 0 */
 451               	/* stack size = 0 */
 452               	.L__stack_usage = 0
 110:RP6Lib/RP6control/RP6ControlLib.c **** 	SPDR = data;    
 453               		.loc 1 110 0
 454 012c 8FB9      		out 0xf,r24
 455               	.L18:
 111:RP6Lib/RP6control/RP6ControlLib.c **** 	while(!(SPSR & (1<<SPIF)));
 456               		.loc 1 111 0 discriminator 1
 457 012e 779B      		sbis 0xe,7
 458 0130 00C0      		rjmp .L18
 459               	/* epilogue start */
 112:RP6Lib/RP6control/RP6ControlLib.c **** }
 460               		.loc 1 112 0
 461 0132 0895      		ret
 462               		.cfi_endproc
 463               	.LFE21:
 465               	.global	readSPI
 467               	readSPI:
 468               	.LFB22:
 113:RP6Lib/RP6control/RP6ControlLib.c **** 
 114:RP6Lib/RP6control/RP6ControlLib.c **** /**
 115:RP6Lib/RP6control/RP6ControlLib.c ****  * Reads a single Databyte from the SPI Interface.
 116:RP6Lib/RP6control/RP6ControlLib.c ****  */
 117:RP6Lib/RP6control/RP6ControlLib.c **** uint8_t readSPI(void)
 118:RP6Lib/RP6control/RP6ControlLib.c **** {
 469               		.loc 1 118 0
 470               		.cfi_startproc
 471               	/* prologue: function */
 472               	/* frame size = 0 */
 473               	/* stack size = 0 */
 474               	.L__stack_usage = 0
 119:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(0xFF);
 475               		.loc 1 119 0
 476 0134 8FEF      		ldi r24,lo8(-1)
 477 0136 0E94 0000 		call writeSPI
 478               	.LVL12:
 120:RP6Lib/RP6control/RP6ControlLib.c **** 	return SPDR;
 479               		.loc 1 120 0
 480 013a 8FB1      		in r24,0xf
 121:RP6Lib/RP6control/RP6ControlLib.c **** }
 481               		.loc 1 121 0
 482 013c 0895      		ret
 483               		.cfi_endproc
 484               	.LFE22:
 486               	.global	readWordSPI
 488               	readWordSPI:
 489               	.LFB23:
 122:RP6Lib/RP6control/RP6ControlLib.c **** 
 123:RP6Lib/RP6control/RP6ControlLib.c **** /**
 124:RP6Lib/RP6control/RP6ControlLib.c ****  * Reads TWO Bytes from the SPI Interface and returns them as
 125:RP6Lib/RP6control/RP6ControlLib.c ****  * a 16 Bit value with first byte read in the upper 8 bits.
 126:RP6Lib/RP6control/RP6ControlLib.c ****  */
 127:RP6Lib/RP6control/RP6ControlLib.c **** uint16_t readWordSPI(void)
 128:RP6Lib/RP6control/RP6ControlLib.c **** {
 490               		.loc 1 128 0
 491               		.cfi_startproc
 492 013e CF93      		push r28
 493               	.LCFI42:
 494               		.cfi_def_cfa_offset 3
 495               		.cfi_offset 28, -2
 496 0140 DF93      		push r29
 497               	.LCFI43:
 498               		.cfi_def_cfa_offset 4
 499               		.cfi_offset 29, -3
 500               	/* prologue: function */
 501               	/* frame size = 0 */
 502               	/* stack size = 2 */
 503               	.L__stack_usage = 2
 504               	.LVL13:
 129:RP6Lib/RP6control/RP6ControlLib.c **** 	uint16_t data = 0;
 130:RP6Lib/RP6control/RP6ControlLib.c **** 	data = readSPI() << 8;
 505               		.loc 1 130 0
 506 0142 0E94 0000 		call readSPI
 507               	.LVL14:
 508 0146 C82F      		mov r28,r24
 509 0148 D0E0      		ldi r29,0
 510 014a DC2F      		mov r29,r28
 511 014c CC27      		clr r28
 512               	.LVL15:
 131:RP6Lib/RP6control/RP6ControlLib.c **** 	data |= readSPI();
 513               		.loc 1 131 0
 514 014e 0E94 0000 		call readSPI
 515               	.LVL16:
 132:RP6Lib/RP6control/RP6ControlLib.c **** 	return data;
 133:RP6Lib/RP6control/RP6ControlLib.c **** }
 516               		.loc 1 133 0
 517 0152 9E01      		movw r18,r28
 518 0154 282B      		or r18,r24
 519 0156 C901      		movw r24,r18
 520               	.LVL17:
 521               	/* epilogue start */
 522 0158 DF91      		pop r29
 523 015a CF91      		pop r28
 524 015c 0895      		ret
 525               		.cfi_endproc
 526               	.LFE23:
 528               	.global	writeWordSPI
 530               	writeWordSPI:
 531               	.LFB24:
 134:RP6Lib/RP6control/RP6ControlLib.c **** 
 135:RP6Lib/RP6control/RP6ControlLib.c **** /**
 136:RP6Lib/RP6control/RP6ControlLib.c ****  * Writes two Bytes contained in the 16 Bit parameter "data".
 137:RP6Lib/RP6control/RP6ControlLib.c ****  * The first byte to be written needs to be in the upper 8 Bits.
 138:RP6Lib/RP6control/RP6ControlLib.c ****  */
 139:RP6Lib/RP6control/RP6ControlLib.c **** void writeWordSPI(uint16_t data)
 140:RP6Lib/RP6control/RP6ControlLib.c **** {
 532               		.loc 1 140 0
 533               		.cfi_startproc
 534               	.LVL18:
 535 015e CF93      		push r28
 536               	.LCFI44:
 537               		.cfi_def_cfa_offset 3
 538               		.cfi_offset 28, -2
 539               	/* prologue: function */
 540               	/* frame size = 0 */
 541               	/* stack size = 1 */
 542               	.L__stack_usage = 1
 543 0160 C82F      		mov r28,r24
 141:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI((uint8_t)(data >> 8));
 544               		.loc 1 141 0
 545 0162 892F      		mov r24,r25
 546               	.LVL19:
 547 0164 0E94 0000 		call writeSPI
 548               	.LVL20:
 142:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI((uint8_t)data);
 549               		.loc 1 142 0
 550 0168 8C2F      		mov r24,r28
 551               	/* epilogue start */
 143:RP6Lib/RP6control/RP6ControlLib.c **** }
 552               		.loc 1 143 0
 553 016a CF91      		pop r28
 142:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI((uint8_t)data);
 554               		.loc 1 142 0
 555 016c 0C94 0000 		jmp writeSPI
 556               	.LVL21:
 557               		.cfi_endproc
 558               	.LFE24:
 560               	.global	writeBufferSPI
 562               	writeBufferSPI:
 563               	.LFB25:
 144:RP6Lib/RP6control/RP6ControlLib.c **** 
 145:RP6Lib/RP6control/RP6ControlLib.c **** /** 
 146:RP6Lib/RP6control/RP6ControlLib.c ****  * This function writes up to 255 Bytes to the SPI Interface.
 147:RP6Lib/RP6control/RP6ControlLib.c ****  * The numer of bytes in the Buffer that shall be written is given 
 148:RP6Lib/RP6control/RP6ControlLib.c ****  * by the parameter length.
 149:RP6Lib/RP6control/RP6ControlLib.c ****  */
 150:RP6Lib/RP6control/RP6ControlLib.c **** void writeBufferSPI(uint8_t *buffer, uint8_t length)
 151:RP6Lib/RP6control/RP6ControlLib.c **** {
 564               		.loc 1 151 0
 565               		.cfi_startproc
 566               	.LVL22:
 567               	/* prologue: function */
 568               	/* frame size = 0 */
 569               	/* stack size = 0 */
 570               	.L__stack_usage = 0
 571 0170 282F      		mov r18,r24
 152:RP6Lib/RP6control/RP6ControlLib.c **** 	uint8_t i = 0;
 153:RP6Lib/RP6control/RP6ControlLib.c **** 	for(; i < length; i++) {
 572               		.loc 1 153 0
 573 0172 FC01      		movw r30,r24
 574               	.LVL23:
 575               	.L23:
 576 0174 8E2F      		mov r24,r30
 577 0176 821B      		sub r24,r18
 578               		.loc 1 153 0 is_stmt 0 discriminator 1
 579 0178 8617      		cp r24,r22
 580 017a 00F4      		brsh .L27
 154:RP6Lib/RP6control/RP6ControlLib.c **** 		SPDR = buffer[i];    
 581               		.loc 1 154 0 is_stmt 1
 582 017c 8191      		ld r24,Z+
 583               	.LVL24:
 584 017e 8FB9      		out 0xf,r24
 585               	.L25:
 155:RP6Lib/RP6control/RP6ControlLib.c **** 		while(!(SPSR & (1<<SPIF)));
 586               		.loc 1 155 0 discriminator 1
 587 0180 779B      		sbis 0xe,7
 588 0182 00C0      		rjmp .L25
 589 0184 00C0      		rjmp .L23
 590               	.LVL25:
 591               	.L27:
 592               	/* epilogue start */
 156:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 157:RP6Lib/RP6control/RP6ControlLib.c **** }
 593               		.loc 1 157 0
 594 0186 0895      		ret
 595               		.cfi_endproc
 596               	.LFE25:
 598               	.global	readBufferSPI
 600               	readBufferSPI:
 601               	.LFB26:
 158:RP6Lib/RP6control/RP6ControlLib.c **** 
 159:RP6Lib/RP6control/RP6ControlLib.c **** /** 
 160:RP6Lib/RP6control/RP6ControlLib.c ****  * Reads "length" Bytes from SPI Interface into the buffer.
 161:RP6Lib/RP6control/RP6ControlLib.c ****  */
 162:RP6Lib/RP6control/RP6ControlLib.c **** void readBufferSPI(uint8_t *buffer, uint8_t length)
 163:RP6Lib/RP6control/RP6ControlLib.c **** {
 602               		.loc 1 163 0
 603               		.cfi_startproc
 604               	.LVL26:
 605               	/* prologue: function */
 606               	/* frame size = 0 */
 607               	/* stack size = 0 */
 608               	.L__stack_usage = 0
 609 0188 282F      		mov r18,r24
 164:RP6Lib/RP6control/RP6ControlLib.c **** 	uint8_t i = 0;
 165:RP6Lib/RP6control/RP6ControlLib.c **** 	for(; i < length; i++) {
 610               		.loc 1 165 0
 611 018a FC01      		movw r30,r24
 166:RP6Lib/RP6control/RP6ControlLib.c **** 		SPDR = 0xFF;    
 612               		.loc 1 166 0
 613 018c 9FEF      		ldi r25,lo8(-1)
 614               	.LVL27:
 615               	.L29:
 616 018e 8E2F      		mov r24,r30
 617 0190 821B      		sub r24,r18
 165:RP6Lib/RP6control/RP6ControlLib.c **** 		SPDR = 0xFF;    
 618               		.loc 1 165 0 discriminator 1
 619 0192 8617      		cp r24,r22
 620 0194 00F4      		brsh .L33
 621               		.loc 1 166 0
 622 0196 9FB9      		out 0xf,r25
 623               	.L31:
 167:RP6Lib/RP6control/RP6ControlLib.c **** 		while(!(SPSR & (1<<SPIF)));
 624               		.loc 1 167 0 discriminator 1
 625 0198 779B      		sbis 0xe,7
 626 019a 00C0      		rjmp .L31
 168:RP6Lib/RP6control/RP6ControlLib.c **** 		buffer[i] = SPDR;
 627               		.loc 1 168 0
 628 019c 8FB1      		in r24,0xf
 629 019e 8193      		st Z+,r24
 630               	.LVL28:
 631 01a0 00C0      		rjmp .L29
 632               	.L33:
 633               	/* epilogue start */
 169:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 170:RP6Lib/RP6control/RP6ControlLib.c **** }
 634               		.loc 1 170 0
 635 01a2 0895      		ret
 636               		.cfi_endproc
 637               	.LFE26:
 639               	.global	SPI_EEPROM_readByte
 641               	SPI_EEPROM_readByte:
 642               	.LFB27:
 171:RP6Lib/RP6control/RP6ControlLib.c **** 
 172:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 173:RP6Lib/RP6control/RP6ControlLib.c **** // External 32KB SPI EEPROM:
 174:RP6Lib/RP6control/RP6ControlLib.c **** 
 175:RP6Lib/RP6control/RP6ControlLib.c **** /**
 176:RP6Lib/RP6control/RP6ControlLib.c ****  * Reads a single Byte from the external EEPROM.
 177:RP6Lib/RP6control/RP6ControlLib.c ****  */
 178:RP6Lib/RP6control/RP6ControlLib.c **** uint8_t SPI_EEPROM_readByte(uint16_t memAddr)
 179:RP6Lib/RP6control/RP6ControlLib.c **** {
 643               		.loc 1 179 0
 644               		.cfi_startproc
 645               	.LVL29:
 646 01a4 CF93      		push r28
 647               	.LCFI45:
 648               		.cfi_def_cfa_offset 3
 649               		.cfi_offset 28, -2
 650 01a6 DF93      		push r29
 651               	.LCFI46:
 652               		.cfi_def_cfa_offset 4
 653               		.cfi_offset 29, -3
 654               	/* prologue: function */
 655               	/* frame size = 0 */
 656               	/* stack size = 2 */
 657               	.L__stack_usage = 2
 658 01a8 EC01      		movw r28,r24
 180:RP6Lib/RP6control/RP6ControlLib.c **** 	uint8_t data;
 181:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 659               		.loc 1 181 0
 660 01aa C098      		cbi 0x18,0
 182:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_READ);
 661               		.loc 1 182 0
 662 01ac 83E0      		ldi r24,lo8(3)
 663               	.LVL30:
 664 01ae 0E94 0000 		call writeSPI
 665               	.LVL31:
 183:RP6Lib/RP6control/RP6ControlLib.c **** 	writeWordSPI(memAddr);
 666               		.loc 1 183 0
 667 01b2 CE01      		movw r24,r28
 668 01b4 0E94 0000 		call writeWordSPI
 669               	.LVL32:
 184:RP6Lib/RP6control/RP6ControlLib.c **** 	data = readSPI();
 670               		.loc 1 184 0
 671 01b8 0E94 0000 		call readSPI
 672               	.LVL33:
 185:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 673               		.loc 1 185 0
 674 01bc C09A      		sbi 0x18,0
 675               	/* epilogue start */
 186:RP6Lib/RP6control/RP6ControlLib.c **** 	return data;
 187:RP6Lib/RP6control/RP6ControlLib.c **** }
 676               		.loc 1 187 0
 677 01be DF91      		pop r29
 678 01c0 CF91      		pop r28
 679               	.LVL34:
 680 01c2 0895      		ret
 681               		.cfi_endproc
 682               	.LFE27:
 684               	.global	SPI_EEPROM_readBytes
 686               	SPI_EEPROM_readBytes:
 687               	.LFB28:
 188:RP6Lib/RP6control/RP6ControlLib.c **** 
 189:RP6Lib/RP6control/RP6ControlLib.c **** /**
 190:RP6Lib/RP6control/RP6ControlLib.c ****  * Reads "length" Bytes into the Buffer "buffer" from startAdr on. 
 191:RP6Lib/RP6control/RP6ControlLib.c ****  * You can read the complete EEPROM into a buffer at once - if it is large enough. 
 192:RP6Lib/RP6control/RP6ControlLib.c ****  * (But you only have 2KB SRAM on a MEGA32 ;) )
 193:RP6Lib/RP6control/RP6ControlLib.c ****  */
 194:RP6Lib/RP6control/RP6ControlLib.c **** void SPI_EEPROM_readBytes(uint16_t startAddr, uint8_t *buffer, uint8_t length)
 195:RP6Lib/RP6control/RP6ControlLib.c **** {
 688               		.loc 1 195 0
 689               		.cfi_startproc
 690               	.LVL35:
 691 01c4 EF92      		push r14
 692               	.LCFI47:
 693               		.cfi_def_cfa_offset 3
 694               		.cfi_offset 14, -2
 695 01c6 FF92      		push r15
 696               	.LCFI48:
 697               		.cfi_def_cfa_offset 4
 698               		.cfi_offset 15, -3
 699 01c8 0F93      		push r16
 700               	.LCFI49:
 701               		.cfi_def_cfa_offset 5
 702               		.cfi_offset 16, -4
 703 01ca 1F93      		push r17
 704               	.LCFI50:
 705               		.cfi_def_cfa_offset 6
 706               		.cfi_offset 17, -5
 707 01cc CF93      		push r28
 708               	.LCFI51:
 709               		.cfi_def_cfa_offset 7
 710               		.cfi_offset 28, -6
 711 01ce DF93      		push r29
 712               	.LCFI52:
 713               		.cfi_def_cfa_offset 8
 714               		.cfi_offset 29, -7
 715 01d0 1F92      		push __zero_reg__
 716               	.LCFI53:
 717               		.cfi_def_cfa_offset 9
 718 01d2 CDB7      		in r28,__SP_L__
 719 01d4 DEB7      		in r29,__SP_H__
 720               	.LCFI54:
 721               		.cfi_def_cfa_register 28
 722               	/* prologue: function */
 723               	/* frame size = 1 */
 724               	/* stack size = 7 */
 725               	.L__stack_usage = 7
 726 01d6 7C01      		movw r14,r24
 727 01d8 8B01      		movw r16,r22
 196:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 728               		.loc 1 196 0
 729 01da C098      		cbi 0x18,0
 197:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_READ);
 730               		.loc 1 197 0
 731 01dc 83E0      		ldi r24,lo8(3)
 732               	.LVL36:
 733 01de 4983      		std Y+1,r20
 734 01e0 0E94 0000 		call writeSPI
 735               	.LVL37:
 198:RP6Lib/RP6control/RP6ControlLib.c **** 	writeWordSPI(startAddr);
 736               		.loc 1 198 0
 737 01e4 C701      		movw r24,r14
 738 01e6 0E94 0000 		call writeWordSPI
 739               	.LVL38:
 199:RP6Lib/RP6control/RP6ControlLib.c **** 	readBufferSPI(&buffer[0], length);
 740               		.loc 1 199 0
 741 01ea 4981      		ldd r20,Y+1
 742 01ec 642F      		mov r22,r20
 743 01ee C801      		movw r24,r16
 744 01f0 0E94 0000 		call readBufferSPI
 745               	.LVL39:
 200:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 746               		.loc 1 200 0
 747 01f4 C09A      		sbi 0x18,0
 748               	/* epilogue start */
 201:RP6Lib/RP6control/RP6ControlLib.c **** }
 749               		.loc 1 201 0
 750 01f6 0F90      		pop __tmp_reg__
 751 01f8 DF91      		pop r29
 752 01fa CF91      		pop r28
 753 01fc 1F91      		pop r17
 754 01fe 0F91      		pop r16
 755               	.LVL40:
 756 0200 FF90      		pop r15
 757 0202 EF90      		pop r14
 758               	.LVL41:
 759 0204 0895      		ret
 760               		.cfi_endproc
 761               	.LFE28:
 763               	.global	SPI_EEPROM_enableWrite
 765               	SPI_EEPROM_enableWrite:
 766               	.LFB29:
 202:RP6Lib/RP6control/RP6ControlLib.c **** 
 203:RP6Lib/RP6control/RP6ControlLib.c **** /**
 204:RP6Lib/RP6control/RP6ControlLib.c ****  * Enable Write Mode
 205:RP6Lib/RP6control/RP6ControlLib.c ****  */
 206:RP6Lib/RP6control/RP6ControlLib.c **** void SPI_EEPROM_enableWrite(void)
 207:RP6Lib/RP6control/RP6ControlLib.c **** {
 767               		.loc 1 207 0
 768               		.cfi_startproc
 769               	/* prologue: function */
 770               	/* frame size = 0 */
 771               	/* stack size = 0 */
 772               	.L__stack_usage = 0
 208:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 773               		.loc 1 208 0
 774 0206 C098      		cbi 0x18,0
 209:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_WREN);
 775               		.loc 1 209 0
 776 0208 86E0      		ldi r24,lo8(6)
 777 020a 0E94 0000 		call writeSPI
 778               	.LVL42:
 210:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 779               		.loc 1 210 0
 780 020e C09A      		sbi 0x18,0
 781 0210 0895      		ret
 782               		.cfi_endproc
 783               	.LFE29:
 785               	.global	SPI_EEPROM_disableWrite
 787               	SPI_EEPROM_disableWrite:
 788               	.LFB30:
 211:RP6Lib/RP6control/RP6ControlLib.c **** }
 212:RP6Lib/RP6control/RP6ControlLib.c **** 
 213:RP6Lib/RP6control/RP6ControlLib.c **** /**
 214:RP6Lib/RP6control/RP6ControlLib.c ****  * Disable Write Mode
 215:RP6Lib/RP6control/RP6ControlLib.c ****  */
 216:RP6Lib/RP6control/RP6ControlLib.c **** void SPI_EEPROM_disableWrite(void)
 217:RP6Lib/RP6control/RP6ControlLib.c **** {
 789               		.loc 1 217 0
 790               		.cfi_startproc
 791               	/* prologue: function */
 792               	/* frame size = 0 */
 793               	/* stack size = 0 */
 794               	.L__stack_usage = 0
 218:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 795               		.loc 1 218 0
 796 0212 C098      		cbi 0x18,0
 219:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_WRDI);
 797               		.loc 1 219 0
 798 0214 84E0      		ldi r24,lo8(4)
 799 0216 0E94 0000 		call writeSPI
 800               	.LVL43:
 220:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 801               		.loc 1 220 0
 802 021a C09A      		sbi 0x18,0
 803 021c 0895      		ret
 804               		.cfi_endproc
 805               	.LFE30:
 807               	.global	SPI_EEPROM_getStatus
 809               	SPI_EEPROM_getStatus:
 810               	.LFB33:
 221:RP6Lib/RP6control/RP6ControlLib.c **** }
 222:RP6Lib/RP6control/RP6ControlLib.c **** 
 223:RP6Lib/RP6control/RP6ControlLib.c **** /**
 224:RP6Lib/RP6control/RP6ControlLib.c ****  * Write a single data byte to the specified EEPROM address.
 225:RP6Lib/RP6control/RP6ControlLib.c ****  */
 226:RP6Lib/RP6control/RP6ControlLib.c **** void SPI_EEPROM_writeByte(uint16_t memAddr, uint8_t data)
 227:RP6Lib/RP6control/RP6ControlLib.c **** {
 228:RP6Lib/RP6control/RP6ControlLib.c **** 	while(SPI_EEPROM_getStatus() & SPI_EEPROM_STAT_WIP);
 229:RP6Lib/RP6control/RP6ControlLib.c **** 	SPI_EEPROM_enableWrite();
 230:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 231:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_WRITE);
 232:RP6Lib/RP6control/RP6ControlLib.c **** 	writeWordSPI(memAddr);
 233:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(data);
 234:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 235:RP6Lib/RP6control/RP6ControlLib.c **** }
 236:RP6Lib/RP6control/RP6ControlLib.c **** 
 237:RP6Lib/RP6control/RP6ControlLib.c **** /**
 238:RP6Lib/RP6control/RP6ControlLib.c ****  * Write "length" Bytes from the Buffer to the EEPROM. 
 239:RP6Lib/RP6control/RP6ControlLib.c ****  * YOU CAN ONLY WRITE MAXIMAL 64 BYTES AT ONCE!!! This is the Pagesize!
 240:RP6Lib/RP6control/RP6ControlLib.c ****  * You can NOT cross a page boundary! For example when you write 20 Bytes 
 241:RP6Lib/RP6control/RP6ControlLib.c ****  * starting at address 54, you will not write up to Byte address 74, but
 242:RP6Lib/RP6control/RP6ControlLib.c ****  * instead only up to 63 and then it continues at Byte 0 and writes 
 243:RP6Lib/RP6control/RP6ControlLib.c ****  * the rest up to Byte 10!
 244:RP6Lib/RP6control/RP6ControlLib.c ****  *
 245:RP6Lib/RP6control/RP6ControlLib.c ****  */
 246:RP6Lib/RP6control/RP6ControlLib.c **** void SPI_EEPROM_writeBytes(uint16_t startAddr, uint8_t *buffer, uint8_t length)
 247:RP6Lib/RP6control/RP6ControlLib.c **** {
 248:RP6Lib/RP6control/RP6ControlLib.c **** 	while(SPI_EEPROM_getStatus() & SPI_EEPROM_STAT_WIP);
 249:RP6Lib/RP6control/RP6ControlLib.c **** 	SPI_EEPROM_enableWrite();
 250:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 251:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_WRITE);
 252:RP6Lib/RP6control/RP6ControlLib.c **** 	writeWordSPI(startAddr);
 253:RP6Lib/RP6control/RP6ControlLib.c **** 	writeBufferSPI(&buffer[0], length);
 254:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 255:RP6Lib/RP6control/RP6ControlLib.c **** }
 256:RP6Lib/RP6control/RP6ControlLib.c **** 
 257:RP6Lib/RP6control/RP6ControlLib.c **** /**
 258:RP6Lib/RP6control/RP6ControlLib.c ****  * Returns EEPROM Status register - for checking if EEPROM is buisy. 
 259:RP6Lib/RP6control/RP6ControlLib.c ****  * Writing takes about 5ms. 
 260:RP6Lib/RP6control/RP6ControlLib.c ****  */
 261:RP6Lib/RP6control/RP6ControlLib.c **** uint8_t SPI_EEPROM_getStatus(void)
 262:RP6Lib/RP6control/RP6ControlLib.c **** {
 811               		.loc 1 262 0
 812               		.cfi_startproc
 813               	/* prologue: function */
 814               	/* frame size = 0 */
 815               	/* stack size = 0 */
 816               	.L__stack_usage = 0
 263:RP6Lib/RP6control/RP6ControlLib.c **** 	uint8_t status;
 264:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 817               		.loc 1 264 0
 818 021e C098      		cbi 0x18,0
 265:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_RDSR);
 819               		.loc 1 265 0
 820 0220 85E0      		ldi r24,lo8(5)
 821 0222 0E94 0000 		call writeSPI
 822               	.LVL44:
 266:RP6Lib/RP6control/RP6ControlLib.c **** 	status = readSPI();
 823               		.loc 1 266 0
 824 0226 0E94 0000 		call readSPI
 825               	.LVL45:
 267:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 826               		.loc 1 267 0
 827 022a C09A      		sbi 0x18,0
 268:RP6Lib/RP6control/RP6ControlLib.c **** 	return status;
 269:RP6Lib/RP6control/RP6ControlLib.c **** }
 828               		.loc 1 269 0
 829 022c 0895      		ret
 830               		.cfi_endproc
 831               	.LFE33:
 833               	.global	SPI_EEPROM_writeByte
 835               	SPI_EEPROM_writeByte:
 836               	.LFB31:
 227:RP6Lib/RP6control/RP6ControlLib.c **** 	while(SPI_EEPROM_getStatus() & SPI_EEPROM_STAT_WIP);
 837               		.loc 1 227 0
 838               		.cfi_startproc
 839               	.LVL46:
 840 022e 1F93      		push r17
 841               	.LCFI55:
 842               		.cfi_def_cfa_offset 3
 843               		.cfi_offset 17, -2
 844 0230 CF93      		push r28
 845               	.LCFI56:
 846               		.cfi_def_cfa_offset 4
 847               		.cfi_offset 28, -3
 848 0232 DF93      		push r29
 849               	.LCFI57:
 850               		.cfi_def_cfa_offset 5
 851               		.cfi_offset 29, -4
 852               	/* prologue: function */
 853               	/* frame size = 0 */
 854               	/* stack size = 3 */
 855               	.L__stack_usage = 3
 856 0234 EC01      		movw r28,r24
 857 0236 162F      		mov r17,r22
 858               	.LVL47:
 859               	.L41:
 228:RP6Lib/RP6control/RP6ControlLib.c **** 	SPI_EEPROM_enableWrite();
 860               		.loc 1 228 0 discriminator 1
 861 0238 0E94 0000 		call SPI_EEPROM_getStatus
 862               	.LVL48:
 863 023c 80FD      		sbrc r24,0
 864 023e 00C0      		rjmp .L41
 229:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 865               		.loc 1 229 0
 866 0240 0E94 0000 		call SPI_EEPROM_enableWrite
 867               	.LVL49:
 230:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_WRITE);
 868               		.loc 1 230 0
 869 0244 C098      		cbi 0x18,0
 231:RP6Lib/RP6control/RP6ControlLib.c **** 	writeWordSPI(memAddr);
 870               		.loc 1 231 0
 871 0246 82E0      		ldi r24,lo8(2)
 872 0248 0E94 0000 		call writeSPI
 873               	.LVL50:
 232:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(data);
 874               		.loc 1 232 0
 875 024c CE01      		movw r24,r28
 876 024e 0E94 0000 		call writeWordSPI
 877               	.LVL51:
 233:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 878               		.loc 1 233 0
 879 0252 812F      		mov r24,r17
 880 0254 0E94 0000 		call writeSPI
 881               	.LVL52:
 234:RP6Lib/RP6control/RP6ControlLib.c **** }
 882               		.loc 1 234 0
 883 0258 C09A      		sbi 0x18,0
 884               	/* epilogue start */
 235:RP6Lib/RP6control/RP6ControlLib.c **** 
 885               		.loc 1 235 0
 886 025a DF91      		pop r29
 887 025c CF91      		pop r28
 888               	.LVL53:
 889 025e 1F91      		pop r17
 890               	.LVL54:
 891 0260 0895      		ret
 892               		.cfi_endproc
 893               	.LFE31:
 895               	.global	SPI_EEPROM_writeBytes
 897               	SPI_EEPROM_writeBytes:
 898               	.LFB32:
 247:RP6Lib/RP6control/RP6ControlLib.c **** 	while(SPI_EEPROM_getStatus() & SPI_EEPROM_STAT_WIP);
 899               		.loc 1 247 0
 900               		.cfi_startproc
 901               	.LVL55:
 902 0262 FF92      		push r15
 903               	.LCFI58:
 904               		.cfi_def_cfa_offset 3
 905               		.cfi_offset 15, -2
 906 0264 0F93      		push r16
 907               	.LCFI59:
 908               		.cfi_def_cfa_offset 4
 909               		.cfi_offset 16, -3
 910 0266 1F93      		push r17
 911               	.LCFI60:
 912               		.cfi_def_cfa_offset 5
 913               		.cfi_offset 17, -4
 914 0268 CF93      		push r28
 915               	.LCFI61:
 916               		.cfi_def_cfa_offset 6
 917               		.cfi_offset 28, -5
 918 026a DF93      		push r29
 919               	.LCFI62:
 920               		.cfi_def_cfa_offset 7
 921               		.cfi_offset 29, -6
 922               	/* prologue: function */
 923               	/* frame size = 0 */
 924               	/* stack size = 5 */
 925               	.L__stack_usage = 5
 926 026c EC01      		movw r28,r24
 927 026e 8B01      		movw r16,r22
 928 0270 F42E      		mov r15,r20
 929               	.LVL56:
 930               	.L44:
 248:RP6Lib/RP6control/RP6ControlLib.c **** 	SPI_EEPROM_enableWrite();
 931               		.loc 1 248 0 discriminator 1
 932 0272 0E94 0000 		call SPI_EEPROM_getStatus
 933               	.LVL57:
 934 0276 80FD      		sbrc r24,0
 935 0278 00C0      		rjmp .L44
 249:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~MEM_CS;
 936               		.loc 1 249 0
 937 027a 0E94 0000 		call SPI_EEPROM_enableWrite
 938               	.LVL58:
 250:RP6Lib/RP6control/RP6ControlLib.c **** 	writeSPI(SPI_EEPROM_WRITE);
 939               		.loc 1 250 0
 940 027e C098      		cbi 0x18,0
 251:RP6Lib/RP6control/RP6ControlLib.c **** 	writeWordSPI(startAddr);
 941               		.loc 1 251 0
 942 0280 82E0      		ldi r24,lo8(2)
 943 0282 0E94 0000 		call writeSPI
 944               	.LVL59:
 252:RP6Lib/RP6control/RP6ControlLib.c **** 	writeBufferSPI(&buffer[0], length);
 945               		.loc 1 252 0
 946 0286 CE01      		movw r24,r28
 947 0288 0E94 0000 		call writeWordSPI
 948               	.LVL60:
 253:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= MEM_CS;
 949               		.loc 1 253 0
 950 028c 6F2D      		mov r22,r15
 951 028e C801      		movw r24,r16
 952 0290 0E94 0000 		call writeBufferSPI
 953               	.LVL61:
 254:RP6Lib/RP6control/RP6ControlLib.c **** }
 954               		.loc 1 254 0
 955 0294 C09A      		sbi 0x18,0
 956               	/* epilogue start */
 255:RP6Lib/RP6control/RP6ControlLib.c **** 
 957               		.loc 1 255 0
 958 0296 DF91      		pop r29
 959 0298 CF91      		pop r28
 960               	.LVL62:
 961 029a 1F91      		pop r17
 962 029c 0F91      		pop r16
 963               	.LVL63:
 964 029e FF90      		pop r15
 965               	.LVL64:
 966 02a0 0895      		ret
 967               		.cfi_endproc
 968               	.LFE32:
 970               	.global	outputExt
 972               	outputExt:
 973               	.LFB34:
 270:RP6Lib/RP6control/RP6ControlLib.c **** 
 271:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 272:RP6Lib/RP6control/RP6ControlLib.c **** // External Port - LEDs and LCD:
 273:RP6Lib/RP6control/RP6ControlLib.c **** 
 274:RP6Lib/RP6control/RP6ControlLib.c **** // A shadow register for the external shift register:
 275:RP6Lib/RP6control/RP6ControlLib.c **** externalPort_t externalPort;
 276:RP6Lib/RP6control/RP6ControlLib.c **** 
 277:RP6Lib/RP6control/RP6ControlLib.c **** /**
 278:RP6Lib/RP6control/RP6ControlLib.c ****  * This routine outputs the value in the shadow register "externalPort" 
 279:RP6Lib/RP6control/RP6ControlLib.c ****  * to the external 8bit shift register on the RP6 Control board with the 
 280:RP6Lib/RP6control/RP6ControlLib.c ****  * hardware SPI module.
 281:RP6Lib/RP6control/RP6ControlLib.c ****  * The lower four bits are connected to the four LEDs, and the upper 
 282:RP6Lib/RP6control/RP6ControlLib.c ****  * to the 4bit LCD databus. (The LCD can be configured to operate
 283:RP6Lib/RP6control/RP6ControlLib.c ****  * in 4 or 8bit mode - we use 4bit mode to save portpins) 
 284:RP6Lib/RP6control/RP6ControlLib.c ****  *
 285:RP6Lib/RP6control/RP6ControlLib.c ****  */
 286:RP6Lib/RP6control/RP6ControlLib.c **** void outputExt(void)
 287:RP6Lib/RP6control/RP6ControlLib.c **** {      
 974               		.loc 1 287 0
 975               		.cfi_startproc
 976               	/* prologue: function */
 977               	/* frame size = 0 */
 978               	/* stack size = 0 */
 979               	.L__stack_usage = 0
 288:RP6Lib/RP6control/RP6ControlLib.c ****   writeSPI(externalPort.byte);   
 980               		.loc 1 288 0
 981 02a2 8091 0000 		lds r24,externalPort
 982 02a6 0E94 0000 		call writeSPI
 983               	.LVL65:
 289:RP6Lib/RP6control/RP6ControlLib.c ****   PORTD |= STR;
 984               		.loc 1 289 0
 985 02aa 949A      		sbi 0x12,4
 290:RP6Lib/RP6control/RP6ControlLib.c ****   nop();
 986               		.loc 1 290 0
 987               	/* #APP */
 988               	 ;  290 "RP6Lib/RP6control/RP6ControlLib.c" 1
 989 02ac 0000      		nop
 990               		
 991               	 ;  0 "" 2
 291:RP6Lib/RP6control/RP6ControlLib.c ****   nop();
 992               		.loc 1 291 0
 993               	 ;  291 "RP6Lib/RP6control/RP6ControlLib.c" 1
 994 02ae 0000      		nop
 995               		
 996               	 ;  0 "" 2
 292:RP6Lib/RP6control/RP6ControlLib.c ****   PORTD &= ~STR;        
 997               		.loc 1 292 0
 998               	/* #NOAPP */
 999 02b0 9498      		cbi 0x12,4
 1000 02b2 0895      		ret
 1001               		.cfi_endproc
 1002               	.LFE34:
 1004               	.global	setLEDs
 1006               	setLEDs:
 1007               	.LFB35:
 293:RP6Lib/RP6control/RP6ControlLib.c **** }
 294:RP6Lib/RP6control/RP6ControlLib.c **** 
 295:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 296:RP6Lib/RP6control/RP6ControlLib.c **** // LEDs:
 297:RP6Lib/RP6control/RP6ControlLib.c **** 
 298:RP6Lib/RP6control/RP6ControlLib.c **** /**
 299:RP6Lib/RP6control/RP6ControlLib.c ****  * Sets the LEDs - this does not affect the other four port lines that
 300:RP6Lib/RP6control/RP6ControlLib.c ****  * are connected to the LCD! 
 301:RP6Lib/RP6control/RP6ControlLib.c ****  *
 302:RP6Lib/RP6control/RP6ControlLib.c ****  */
 303:RP6Lib/RP6control/RP6ControlLib.c **** void setLEDs(uint8_t leds)
 304:RP6Lib/RP6control/RP6ControlLib.c **** {
 1008               		.loc 1 304 0
 1009               		.cfi_startproc
 1010               	.LVL66:
 1011               	/* prologue: function */
 1012               	/* frame size = 0 */
 1013               	/* stack size = 0 */
 1014               	.L__stack_usage = 0
 305:RP6Lib/RP6control/RP6ControlLib.c **** 	externalPort.LEDS = leds;
 1015               		.loc 1 305 0
 1016 02b4 8F70      		andi r24,lo8(15)
 1017               	.LVL67:
 1018 02b6 9091 0000 		lds r25,externalPort
 1019 02ba 907F      		andi r25,lo8(-16)
 1020 02bc 982B      		or r25,r24
 1021 02be 9093 0000 		sts externalPort,r25
 306:RP6Lib/RP6control/RP6ControlLib.c **** 	outputExt();
 1022               		.loc 1 306 0
 1023 02c2 0C94 0000 		jmp outputExt
 1024               	.LVL68:
 1025               		.cfi_endproc
 1026               	.LFE35:
 1028               	.global	getPressedKeyNumber
 1030               	getPressedKeyNumber:
 1031               	.LFB50:
 307:RP6Lib/RP6control/RP6ControlLib.c **** }
 308:RP6Lib/RP6control/RP6ControlLib.c **** 
 309:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 310:RP6Lib/RP6control/RP6ControlLib.c **** // LCD
 311:RP6Lib/RP6control/RP6ControlLib.c **** // All LCD routines are prepared to control a 2x16 character LCD.
 312:RP6Lib/RP6control/RP6ControlLib.c **** // If you want to connect a bigger LCD you need to change some things in 
 313:RP6Lib/RP6control/RP6ControlLib.c **** // these routines! (especially in the initLCD, setCursorLCD and showScreenLCD
 314:RP6Lib/RP6control/RP6ControlLib.c **** // routines)
 315:RP6Lib/RP6control/RP6ControlLib.c **** 
 316:RP6Lib/RP6control/RP6ControlLib.c **** char lcd_tmp_buffer[17];
 317:RP6Lib/RP6control/RP6ControlLib.c **** 
 318:RP6Lib/RP6control/RP6ControlLib.c **** /**
 319:RP6Lib/RP6control/RP6ControlLib.c ****  * Sets the LCD ports without affecting the LEDs and also pulses the
 320:RP6Lib/RP6control/RP6ControlLib.c ****  * enable line of the LCD to 'inform' the LCD about the new data.
 321:RP6Lib/RP6control/RP6ControlLib.c ****  *
 322:RP6Lib/RP6control/RP6ControlLib.c ****  */
 323:RP6Lib/RP6control/RP6ControlLib.c **** void setLCDD(uint8_t lcdd)
 324:RP6Lib/RP6control/RP6ControlLib.c **** {
 325:RP6Lib/RP6control/RP6ControlLib.c **** 	externalPort.LCDD = lcdd;
 326:RP6Lib/RP6control/RP6ControlLib.c **** 	outputExt();
 327:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= LCD_EN;
 328:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(50);
 329:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~LCD_EN;
 330:RP6Lib/RP6control/RP6ControlLib.c **** }
 331:RP6Lib/RP6control/RP6ControlLib.c **** 
 332:RP6Lib/RP6control/RP6ControlLib.c **** /**
 333:RP6Lib/RP6control/RP6ControlLib.c ****  * Initialize the LCD. Always call this before using the LCD! 
 334:RP6Lib/RP6control/RP6ControlLib.c ****  *
 335:RP6Lib/RP6control/RP6ControlLib.c ****  */
 336:RP6Lib/RP6control/RP6ControlLib.c **** void initLCD(void)
 337:RP6Lib/RP6control/RP6ControlLib.c **** {
 338:RP6Lib/RP6control/RP6ControlLib.c **** 	//delayCycles(34000); No need for Power ON delay as usually the
 339:RP6Lib/RP6control/RP6ControlLib.c **** 	// Bootloader should have been executed before...
 340:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(0b0011);
 341:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(18000);
 342:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(0b0011);
 343:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 344:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(0b0011);
 345:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 346:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(0b0010);
 347:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 348:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00101000);
 349:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 350:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00001000);
 351:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 352:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00000001);
 353:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 354:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00000010);
 355:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 356:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00001100);
 357:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 358:RP6Lib/RP6control/RP6ControlLib.c **** }
 359:RP6Lib/RP6control/RP6ControlLib.c **** 
 360:RP6Lib/RP6control/RP6ControlLib.c **** /**
 361:RP6Lib/RP6control/RP6ControlLib.c ****  * Write a 8bit-byte in two nibbles of 4bit to the LCD.
 362:RP6Lib/RP6control/RP6ControlLib.c ****  */
 363:RP6Lib/RP6control/RP6ControlLib.c **** void write4BitLCDData(uint8_t data)
 364:RP6Lib/RP6control/RP6ControlLib.c **** {
 365:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(data >> 4);
 366:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(data);
 367:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(150);
 368:RP6Lib/RP6control/RP6ControlLib.c **** }
 369:RP6Lib/RP6control/RP6ControlLib.c **** 
 370:RP6Lib/RP6control/RP6ControlLib.c **** /**
 371:RP6Lib/RP6control/RP6ControlLib.c ****  * Write a command to the LCD.
 372:RP6Lib/RP6control/RP6ControlLib.c ****  */
 373:RP6Lib/RP6control/RP6ControlLib.c **** void writeLCDCommand(uint8_t cmd)
 374:RP6Lib/RP6control/RP6ControlLib.c **** {
 375:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~LCD_RS;
 376:RP6Lib/RP6control/RP6ControlLib.c **** 	write4BitLCDData(cmd);
 377:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(150);
 378:RP6Lib/RP6control/RP6ControlLib.c **** }
 379:RP6Lib/RP6control/RP6ControlLib.c **** 
 380:RP6Lib/RP6control/RP6ControlLib.c **** /**
 381:RP6Lib/RP6control/RP6ControlLib.c ****  * Clears the whole LCD!
 382:RP6Lib/RP6control/RP6ControlLib.c ****  */
 383:RP6Lib/RP6control/RP6ControlLib.c **** void clearLCD(void)
 384:RP6Lib/RP6control/RP6ControlLib.c **** {
 385:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00000001);
 386:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 387:RP6Lib/RP6control/RP6ControlLib.c **** }
 388:RP6Lib/RP6control/RP6ControlLib.c **** 
 389:RP6Lib/RP6control/RP6ControlLib.c **** 
 390:RP6Lib/RP6control/RP6ControlLib.c **** /**
 391:RP6Lib/RP6control/RP6ControlLib.c ****  * Write a single character to the LCD.
 392:RP6Lib/RP6control/RP6ControlLib.c ****  *
 393:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 394:RP6Lib/RP6control/RP6ControlLib.c ****  *
 395:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD('R');
 396:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD('P');
 397:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD('6');
 398:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD(' ');
 399:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD('0');
 400:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD(48); // 48 is ASCII code for '0'
 401:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD(49); // '1'
 402:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD(50); // '2'
 403:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeCharLCD(51); // '3'
 404:RP6Lib/RP6control/RP6ControlLib.c ****  *			//...
 405:RP6Lib/RP6control/RP6ControlLib.c ****  *
 406:RP6Lib/RP6control/RP6ControlLib.c ****  *			would output:
 407:RP6Lib/RP6control/RP6ControlLib.c ****  *			RP6 00123
 408:RP6Lib/RP6control/RP6ControlLib.c ****  *			at the current cursor position!
 409:RP6Lib/RP6control/RP6ControlLib.c ****  *			use setCursorPos function to move the cursor to a 
 410:RP6Lib/RP6control/RP6ControlLib.c ****  *			different location!
 411:RP6Lib/RP6control/RP6ControlLib.c ****  */
 412:RP6Lib/RP6control/RP6ControlLib.c **** void writeCharLCD(uint8_t ch)
 413:RP6Lib/RP6control/RP6ControlLib.c **** {
 414:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= LCD_RS;
 415:RP6Lib/RP6control/RP6ControlLib.c **** 	write4BitLCDData(ch);
 416:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(50);
 417:RP6Lib/RP6control/RP6ControlLib.c **** }
 418:RP6Lib/RP6control/RP6ControlLib.c **** 
 419:RP6Lib/RP6control/RP6ControlLib.c **** /**
 420:RP6Lib/RP6control/RP6ControlLib.c ****  * Writes a null terminated string from flash program memory to the LCD.
 421:RP6Lib/RP6control/RP6ControlLib.c ****  * You can use the macro writeStringLCD_P(STRING); instead, this macro
 422:RP6Lib/RP6control/RP6ControlLib.c ****  * ensures that the String is stored in program memory only!
 423:RP6Lib/RP6control/RP6ControlLib.c ****  *
 424:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 425:RP6Lib/RP6control/RP6ControlLib.c ****  *
 426:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeNStringLCD_P(PSTR("RP6 Control"));
 427:RP6Lib/RP6control/RP6ControlLib.c ****  *
 428:RP6Lib/RP6control/RP6ControlLib.c ****  *			// There is also a Macro that makes life easier and
 429:RP6Lib/RP6control/RP6ControlLib.c ****  *			// you can simply write:
 430:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeStringLCD_P("RP6 Control");
 431:RP6Lib/RP6control/RP6ControlLib.c ****  *
 432:RP6Lib/RP6control/RP6ControlLib.c ****  */
 433:RP6Lib/RP6control/RP6ControlLib.c **** void writeNStringLCD_P(const char *pstring)
 434:RP6Lib/RP6control/RP6ControlLib.c **** {
 435:RP6Lib/RP6control/RP6ControlLib.c ****     uint8_t c;
 436:RP6Lib/RP6control/RP6ControlLib.c ****     for (;(c = pgm_read_byte_near(pstring++));writeCharLCD(c));
 437:RP6Lib/RP6control/RP6ControlLib.c **** }
 438:RP6Lib/RP6control/RP6ControlLib.c **** 
 439:RP6Lib/RP6control/RP6ControlLib.c **** /**
 440:RP6Lib/RP6control/RP6ControlLib.c ****  * Writes a String from SRAM to the LCD.
 441:RP6Lib/RP6control/RP6ControlLib.c ****  */
 442:RP6Lib/RP6control/RP6ControlLib.c **** void writeStringLCD(char *string)
 443:RP6Lib/RP6control/RP6ControlLib.c **** {
 444:RP6Lib/RP6control/RP6ControlLib.c **** 	while(*string)
 445:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(*string++);
 446:RP6Lib/RP6control/RP6ControlLib.c **** }
 447:RP6Lib/RP6control/RP6ControlLib.c **** 
 448:RP6Lib/RP6control/RP6ControlLib.c **** /**
 449:RP6Lib/RP6control/RP6ControlLib.c ****  * Writes a string with specified length and offset from SRAM to the LCD.
 450:RP6Lib/RP6control/RP6ControlLib.c ****  * If it is a null terminated string, output will be stopped at the
 451:RP6Lib/RP6control/RP6ControlLib.c ****  * end. It does not need to be null terminated, but it is recommended
 452:RP6Lib/RP6control/RP6ControlLib.c ****  * to use only null terminated strings/buffers, otherwise the function could
 453:RP6Lib/RP6control/RP6ControlLib.c ****  * output any SRAM memory data stored after the string until it reaches a 0
 454:RP6Lib/RP6control/RP6ControlLib.c ****  * or the specified length!
 455:RP6Lib/RP6control/RP6ControlLib.c ****  *
 456:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 457:RP6Lib/RP6control/RP6ControlLib.c ****  *
 458:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeStringLength("RP6 Robot Sytem",16,0);
 459:RP6Lib/RP6control/RP6ControlLib.c ****  *			// would output: "RP6 Robot Sytem\n"
 460:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeStringLength("RP6 Robot Sytem",11,4);
 461:RP6Lib/RP6control/RP6ControlLib.c ****  *			// would output: "Robot System"
 462:RP6Lib/RP6control/RP6ControlLib.c ****  * 			writeStringLength("RP6 Robot Sytem",40,4);
 463:RP6Lib/RP6control/RP6ControlLib.c ****  *			// would output: "Robot System"
 464:RP6Lib/RP6control/RP6ControlLib.c ****  *			// No matter if the specified length is 40 characters!
 465:RP6Lib/RP6control/RP6ControlLib.c ****  *
 466:RP6Lib/RP6control/RP6ControlLib.c ****  */
 467:RP6Lib/RP6control/RP6ControlLib.c **** void writeStringLengthLCD(char *string, uint8_t length, uint8_t offset)
 468:RP6Lib/RP6control/RP6ControlLib.c **** {
 469:RP6Lib/RP6control/RP6ControlLib.c **** 	for(string = &string[offset]; *string && length; length--)
 470:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(*string++);
 471:RP6Lib/RP6control/RP6ControlLib.c **** }
 472:RP6Lib/RP6control/RP6ControlLib.c **** 
 473:RP6Lib/RP6control/RP6ControlLib.c **** /**
 474:RP6Lib/RP6control/RP6ControlLib.c ****  * Write a number (with specified base) to the LCD.
 475:RP6Lib/RP6control/RP6ControlLib.c ****  *
 476:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 477:RP6Lib/RP6control/RP6ControlLib.c ****  *
 478:RP6Lib/RP6control/RP6ControlLib.c ****  *			// Write a hexadecimal number to the LCD:
 479:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeInteger(0xAACC,16);
 480:RP6Lib/RP6control/RP6ControlLib.c ****  *			// Instead of 16 you can also write "HEX" as this is defined in the
 481:RP6Lib/RP6control/RP6ControlLib.c ****  *			// RP6RobotBaseLib.h :
 482:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeInteger(0xAACC, HEX);
 483:RP6Lib/RP6control/RP6ControlLib.c ****  *			// Other Formats:
 484:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeInteger(1024,DEC);  	// Decimal
 485:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeInteger(511,OCT);		// Ocal
 486:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeInteger(0b11010111,BIN); // Binary
 487:RP6Lib/RP6control/RP6ControlLib.c ****  */
 488:RP6Lib/RP6control/RP6ControlLib.c **** void writeIntegerLCD(int16_t number, uint8_t base)
 489:RP6Lib/RP6control/RP6ControlLib.c **** {
 490:RP6Lib/RP6control/RP6ControlLib.c **** 	itoa(number, &lcd_tmp_buffer[0], base);
 491:RP6Lib/RP6control/RP6ControlLib.c **** 	writeStringLCD(&lcd_tmp_buffer[0]);
 492:RP6Lib/RP6control/RP6ControlLib.c **** }
 493:RP6Lib/RP6control/RP6ControlLib.c **** 
 494:RP6Lib/RP6control/RP6ControlLib.c **** /**
 495:RP6Lib/RP6control/RP6ControlLib.c ****  * Same as writeInteger, but with defined length.
 496:RP6Lib/RP6control/RP6ControlLib.c ****  * This means this routine will add leading zeros to the number if length is
 497:RP6Lib/RP6control/RP6ControlLib.c ****  * larger than the actual value or cut the upper digits if length is smaller
 498:RP6Lib/RP6control/RP6ControlLib.c ****  * than the actual value.
 499:RP6Lib/RP6control/RP6ControlLib.c ****  *
 500:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 501:RP6Lib/RP6control/RP6ControlLib.c ****  *
 502:RP6Lib/RP6control/RP6ControlLib.c ****  *			// Write a hexadecimal number to the LCD:
 503:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeIntegerLength(0xAACC, 16, 8);
 504:RP6Lib/RP6control/RP6ControlLib.c ****  *			// Instead of 16 you can also write "HEX" as this is defined in the
 505:RP6Lib/RP6control/RP6ControlLib.c ****  *			// RP6ControlLib.h :
 506:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeIntegerLength(0xAACC, HEX, 8);
 507:RP6Lib/RP6control/RP6ControlLib.c ****  *			// Other Formats:
 508:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeIntegerLength(1024,DEC,6);  	// Decimal
 509:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeIntegerLength(511,OCT,4);		// Ocal
 510:RP6Lib/RP6control/RP6ControlLib.c ****  *			writeIntegerLength(0b11010111,BIN,8); // Binary
 511:RP6Lib/RP6control/RP6ControlLib.c ****  */
 512:RP6Lib/RP6control/RP6ControlLib.c ****  
 513:RP6Lib/RP6control/RP6ControlLib.c **** void writeIntegerLengthLCD(int16_t number, uint8_t base, uint8_t length)
 514:RP6Lib/RP6control/RP6ControlLib.c **** {
 515:RP6Lib/RP6control/RP6ControlLib.c **** 	char buffer[17];
 516:RP6Lib/RP6control/RP6ControlLib.c **** 	itoa(number, &buffer[0], base);
 517:RP6Lib/RP6control/RP6ControlLib.c **** 	int8_t cnt = length - strlen(buffer);
 518:RP6Lib/RP6control/RP6ControlLib.c **** 	if(cnt > 0) {
 519:RP6Lib/RP6control/RP6ControlLib.c **** 		for(; cnt > 0; cnt--, writeCharLCD('0'));
 520:RP6Lib/RP6control/RP6ControlLib.c **** 		writeStringLCD(&buffer[0]);
 521:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 522:RP6Lib/RP6control/RP6ControlLib.c **** 	else 
 523:RP6Lib/RP6control/RP6ControlLib.c **** 		writeStringLengthLCD(&buffer[0],length,-cnt);
 524:RP6Lib/RP6control/RP6ControlLib.c **** }
 525:RP6Lib/RP6control/RP6ControlLib.c **** 
 526:RP6Lib/RP6control/RP6ControlLib.c **** /**
 527:RP6Lib/RP6control/RP6ControlLib.c ****  * This function is useful for displaying text screens on the LCD.
 528:RP6Lib/RP6control/RP6ControlLib.c ****  * It clears the whole LCD and writes the two Strings to line 1 and
 529:RP6Lib/RP6control/RP6ControlLib.c ****  * line 2.
 530:RP6Lib/RP6control/RP6ControlLib.c ****  */
 531:RP6Lib/RP6control/RP6ControlLib.c **** void _showScreenLCD_P(const char *line1, const char *line2)
 532:RP6Lib/RP6control/RP6ControlLib.c **** {
 533:RP6Lib/RP6control/RP6ControlLib.c **** 	clearLCD();
 534:RP6Lib/RP6control/RP6ControlLib.c **** 	writeNStringLCD_P(line1);
 535:RP6Lib/RP6control/RP6ControlLib.c **** 	setCursorPosLCD(1, 0);
 536:RP6Lib/RP6control/RP6ControlLib.c **** 	writeNStringLCD_P(line2);
 537:RP6Lib/RP6control/RP6ControlLib.c **** }
 538:RP6Lib/RP6control/RP6ControlLib.c **** 
 539:RP6Lib/RP6control/RP6ControlLib.c **** /**
 540:RP6Lib/RP6control/RP6ControlLib.c ****  * Sets the cursor position on LCD.
 541:RP6Lib/RP6control/RP6ControlLib.c ****  */
 542:RP6Lib/RP6control/RP6ControlLib.c **** void setCursorPosLCD(uint8_t line, uint8_t pos)
 543:RP6Lib/RP6control/RP6ControlLib.c **** {
 544:RP6Lib/RP6control/RP6ControlLib.c **** 	pos |= 128;
 545:RP6Lib/RP6control/RP6ControlLib.c **** 	if(line==1) pos += 0x40;
 546:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(pos);
 547:RP6Lib/RP6control/RP6ControlLib.c **** }
 548:RP6Lib/RP6control/RP6ControlLib.c **** 
 549:RP6Lib/RP6control/RP6ControlLib.c **** /**
 550:RP6Lib/RP6control/RP6ControlLib.c ****  * Clears some characters after the given position.
 551:RP6Lib/RP6control/RP6ControlLib.c ****  */
 552:RP6Lib/RP6control/RP6ControlLib.c **** void clearPosLCD(uint8_t line, uint8_t pos, uint8_t length)
 553:RP6Lib/RP6control/RP6ControlLib.c **** {
 554:RP6Lib/RP6control/RP6ControlLib.c **** 	setCursorPosLCD(line,pos);
 555:RP6Lib/RP6control/RP6ControlLib.c **** 	while(length--)
 556:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(' ');
 557:RP6Lib/RP6control/RP6ControlLib.c **** }
 558:RP6Lib/RP6control/RP6ControlLib.c **** 
 559:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 560:RP6Lib/RP6control/RP6ControlLib.c **** // Keypad:
 561:RP6Lib/RP6control/RP6ControlLib.c **** 
 562:RP6Lib/RP6control/RP6ControlLib.c **** /**
 563:RP6Lib/RP6control/RP6ControlLib.c ****  * Checks which key is pressed - returns the key number,
 564:RP6Lib/RP6control/RP6ControlLib.c ****  * or 0, if no key is pressed.
 565:RP6Lib/RP6control/RP6ControlLib.c ****  * Maybe you need to adjust these values because of variations
 566:RP6Lib/RP6control/RP6ControlLib.c ****  * in the resitors of the keypad!
 567:RP6Lib/RP6control/RP6ControlLib.c ****  *
 568:RP6Lib/RP6control/RP6ControlLib.c ****  */
 569:RP6Lib/RP6control/RP6ControlLib.c **** uint8_t getPressedKeyNumber(void)
 570:RP6Lib/RP6control/RP6ControlLib.c **** {
 1032               		.loc 1 570 0
 1033               		.cfi_startproc
 1034 02c6 CF93      		push r28
 1035               	.LCFI63:
 1036               		.cfi_def_cfa_offset 3
 1037               		.cfi_offset 28, -2
 1038 02c8 DF93      		push r29
 1039               	.LCFI64:
 1040               		.cfi_def_cfa_offset 4
 1041               		.cfi_offset 29, -3
 1042               	/* prologue: function */
 1043               	/* frame size = 0 */
 1044               	/* stack size = 2 */
 1045               	.L__stack_usage = 2
 571:RP6Lib/RP6control/RP6ControlLib.c **** 	uint16_t keys;
 572:RP6Lib/RP6control/RP6ControlLib.c **** 	keys = readADC(ADC_KEYPAD);
 1046               		.loc 1 572 0
 1047 02ca 81E0      		ldi r24,lo8(1)
 1048 02cc 0E94 0000 		call readADC
 1049               	.LVL69:
 1050 02d0 EC01      		movw r28,r24
 1051               	.LVL70:
 573:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 1020) {
 1052               		.loc 1 573 0
 1053 02d2 CC3F      		cpi r28,-4
 1054 02d4 83E0      		ldi r24,3
 1055 02d6 D807      		cpc r29,r24
 1056               	.LVL71:
 1057 02d8 00F4      		brsh .L48
 574:RP6Lib/RP6control/RP6ControlLib.c **** 		nop();
 1058               		.loc 1 574 0
 1059               	/* #APP */
 1060               	 ;  574 "RP6Lib/RP6control/RP6ControlLib.c" 1
 1061 02da 0000      		nop
 1062               		
 1063               	 ;  0 "" 2
 575:RP6Lib/RP6control/RP6ControlLib.c **** 		nop();
 1064               		.loc 1 575 0
 1065               	 ;  575 "RP6Lib/RP6control/RP6ControlLib.c" 1
 1066 02dc 0000      		nop
 1067               		
 1068               	 ;  0 "" 2
 576:RP6Lib/RP6control/RP6ControlLib.c **** 		nop();
 1069               		.loc 1 576 0
 1070               	 ;  576 "RP6Lib/RP6control/RP6ControlLib.c" 1
 1071 02de 0000      		nop
 1072               		
 1073               	 ;  0 "" 2
 577:RP6Lib/RP6control/RP6ControlLib.c **** 		keys += readADC(ADC_KEYPAD);
 1074               		.loc 1 577 0
 1075               	/* #NOAPP */
 1076 02e0 81E0      		ldi r24,lo8(1)
 1077 02e2 0E94 0000 		call readADC
 1078               	.LVL72:
 1079 02e6 C80F      		add r28,r24
 1080 02e8 D91F      		adc r29,r25
 1081               	.LVL73:
 578:RP6Lib/RP6control/RP6ControlLib.c **** 		keys >>= 1;
 1082               		.loc 1 578 0
 1083 02ea D695      		lsr r29
 1084 02ec C795      		ror r28
 1085               	.LVL74:
 579:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 580:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 50)
 1086               		.loc 1 580 0
 1087 02ee C233      		cpi r28,50
 1088 02f0 D105      		cpc r29,__zero_reg__
 1089 02f2 00F0      		brlo .L50
 581:RP6Lib/RP6control/RP6ControlLib.c **** 		return 1;
 582:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 580)
 1090               		.loc 1 582 0
 1091 02f4 C434      		cpi r28,68
 1092 02f6 82E0      		ldi r24,2
 1093 02f8 D807      		cpc r29,r24
 1094 02fa 00F0      		brlo .L51
 1095               	.L48:
 583:RP6Lib/RP6control/RP6ControlLib.c **** 		return 2;
 584:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 700)
 1096               		.loc 1 584 0
 1097 02fc CC3B      		cpi r28,-68
 1098 02fe 82E0      		ldi r24,2
 1099 0300 D807      		cpc r29,r24
 1100 0302 00F0      		brlo .L52
 585:RP6Lib/RP6control/RP6ControlLib.c **** 		return 3;
 586:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 790)
 1101               		.loc 1 586 0
 1102 0304 C631      		cpi r28,22
 1103 0306 83E0      		ldi r24,3
 1104 0308 D807      		cpc r29,r24
 1105 030a 00F0      		brlo .L53
 587:RP6Lib/RP6control/RP6ControlLib.c **** 		return 4;
 588:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 830)
 1106               		.loc 1 588 0
 1107 030c CE33      		cpi r28,62
 1108 030e D340      		sbci r29,3
 1109 0310 00F4      		brsh .L54
 589:RP6Lib/RP6control/RP6ControlLib.c **** 		return 5;
 1110               		.loc 1 589 0
 1111 0312 85E0      		ldi r24,lo8(5)
 1112 0314 00C0      		rjmp .L49
 1113               	.L50:
 581:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 580)
 1114               		.loc 1 581 0
 1115 0316 81E0      		ldi r24,lo8(1)
 1116 0318 00C0      		rjmp .L49
 1117               	.L51:
 583:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 700)
 1118               		.loc 1 583 0
 1119 031a 82E0      		ldi r24,lo8(2)
 1120 031c 00C0      		rjmp .L49
 1121               	.L52:
 585:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 790)
 1122               		.loc 1 585 0
 1123 031e 83E0      		ldi r24,lo8(3)
 1124 0320 00C0      		rjmp .L49
 1125               	.L53:
 587:RP6Lib/RP6control/RP6ControlLib.c **** 	if(keys < 830)
 1126               		.loc 1 587 0
 1127 0322 84E0      		ldi r24,lo8(4)
 1128 0324 00C0      		rjmp .L49
 1129               	.L54:
 590:RP6Lib/RP6control/RP6ControlLib.c **** 	return 0;
 1130               		.loc 1 590 0
 1131 0326 80E0      		ldi r24,0
 1132               	.L49:
 1133               	/* epilogue start */
 591:RP6Lib/RP6control/RP6ControlLib.c **** }
 1134               		.loc 1 591 0
 1135 0328 DF91      		pop r29
 1136 032a CF91      		pop r28
 1137               	.LVL75:
 1138 032c 0895      		ret
 1139               		.cfi_endproc
 1140               	.LFE50:
 1142               	.global	checkPressedKeyEvent
 1144               	checkPressedKeyEvent:
 1145               	.LFB51:
 592:RP6Lib/RP6control/RP6ControlLib.c **** 
 593:RP6Lib/RP6control/RP6ControlLib.c **** /**
 594:RP6Lib/RP6control/RP6ControlLib.c ****  * This function has to be called frequently out of
 595:RP6Lib/RP6control/RP6ControlLib.c ****  * the main loop and checks if a button is pressed! It only returns 
 596:RP6Lib/RP6control/RP6ControlLib.c ****  * the key number a single time, DIRECTLY when the button is pressed.
 597:RP6Lib/RP6control/RP6ControlLib.c ****  * 
 598:RP6Lib/RP6control/RP6ControlLib.c ****  * This is useful for non-blocking keyboard check in the
 599:RP6Lib/RP6control/RP6ControlLib.c ****  * main loop. You don't need something like 
 600:RP6Lib/RP6control/RP6ControlLib.c ****  * "while(getPressedKeyNumber());" to wait for the button
 601:RP6Lib/RP6control/RP6ControlLib.c ****  * to be released again!
 602:RP6Lib/RP6control/RP6ControlLib.c ****  */
 603:RP6Lib/RP6control/RP6ControlLib.c **** uint8_t checkPressedKeyEvent(void)
 604:RP6Lib/RP6control/RP6ControlLib.c **** {
 1146               		.loc 1 604 0
 1147               		.cfi_startproc
 1148               	/* prologue: function */
 1149               	/* frame size = 0 */
 1150               	/* stack size = 0 */
 1151               	.L__stack_usage = 0
 605:RP6Lib/RP6control/RP6ControlLib.c **** 	static uint8_t pressed_key = 0;
 606:RP6Lib/RP6control/RP6ControlLib.c **** 	if(pressed_key) {
 1152               		.loc 1 606 0
 1153 032e 8091 0000 		lds r24,pressed_key.2396
 1154 0332 8823      		tst r24
 1155 0334 01F0      		breq .L56
 607:RP6Lib/RP6control/RP6ControlLib.c **** 		if(!getPressedKeyNumber()) 
 1156               		.loc 1 607 0
 1157 0336 0E94 0000 		call getPressedKeyNumber
 1158               	.LVL76:
 1159 033a 8111      		cpse r24,__zero_reg__
 1160 033c 00C0      		rjmp .L58
 608:RP6Lib/RP6control/RP6ControlLib.c **** 			pressed_key = 0;
 1161               		.loc 1 608 0
 1162 033e 1092 0000 		sts pressed_key.2396,__zero_reg__
 1163 0342 0895      		ret
 1164               	.L56:
 609:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 610:RP6Lib/RP6control/RP6ControlLib.c **** 	else {
 611:RP6Lib/RP6control/RP6ControlLib.c **** 		pressed_key = getPressedKeyNumber();
 1165               		.loc 1 611 0
 1166 0344 0E94 0000 		call getPressedKeyNumber
 1167               	.LVL77:
 1168 0348 8093 0000 		sts pressed_key.2396,r24
 1169 034c 0895      		ret
 1170               	.L58:
 612:RP6Lib/RP6control/RP6ControlLib.c **** 		if(pressed_key)
 613:RP6Lib/RP6control/RP6ControlLib.c **** 			return pressed_key;
 614:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 615:RP6Lib/RP6control/RP6ControlLib.c **** 	return 0;
 1171               		.loc 1 615 0
 1172 034e 80E0      		ldi r24,0
 616:RP6Lib/RP6control/RP6ControlLib.c **** }
 1173               		.loc 1 616 0
 1174 0350 0895      		ret
 1175               		.cfi_endproc
 1176               	.LFE51:
 1178               	.global	checkReleasedKeyEvent
 1180               	checkReleasedKeyEvent:
 1181               	.LFB52:
 617:RP6Lib/RP6control/RP6ControlLib.c **** 
 618:RP6Lib/RP6control/RP6ControlLib.c **** /**
 619:RP6Lib/RP6control/RP6ControlLib.c ****  * This function has to be called frequently out of
 620:RP6Lib/RP6control/RP6ControlLib.c ****  * the main loop and checks if a button is pressed AND
 621:RP6Lib/RP6control/RP6ControlLib.c ****  * released. It only returns the key number a single time, 
 622:RP6Lib/RP6control/RP6ControlLib.c ****  * AFTER the button has been released.
 623:RP6Lib/RP6control/RP6ControlLib.c ****  * 
 624:RP6Lib/RP6control/RP6ControlLib.c ****  * This is useful for non-blocking keyboard check in the
 625:RP6Lib/RP6control/RP6ControlLib.c ****  * main loop. You don't need something like 
 626:RP6Lib/RP6control/RP6ControlLib.c ****  * "while(getPressedKeyNumber());" to wait for the button
 627:RP6Lib/RP6control/RP6ControlLib.c ****  * to be released again!
 628:RP6Lib/RP6control/RP6ControlLib.c ****  */
 629:RP6Lib/RP6control/RP6ControlLib.c **** uint8_t checkReleasedKeyEvent(void)
 630:RP6Lib/RP6control/RP6ControlLib.c **** {
 1182               		.loc 1 630 0
 1183               		.cfi_startproc
 1184 0352 CF93      		push r28
 1185               	.LCFI65:
 1186               		.cfi_def_cfa_offset 3
 1187               		.cfi_offset 28, -2
 1188               	/* prologue: function */
 1189               	/* frame size = 0 */
 1190               	/* stack size = 1 */
 1191               	.L__stack_usage = 1
 631:RP6Lib/RP6control/RP6ControlLib.c **** 	static uint8_t released_key = 0;
 632:RP6Lib/RP6control/RP6ControlLib.c **** 	if(released_key) {
 1192               		.loc 1 632 0
 1193 0354 C091 0000 		lds r28,released_key.2400
 1194 0358 CC23      		tst r28
 1195 035a 01F0      		breq .L60
 633:RP6Lib/RP6control/RP6ControlLib.c **** 		if(!getPressedKeyNumber()) {
 1196               		.loc 1 633 0
 1197 035c 0E94 0000 		call getPressedKeyNumber
 1198               	.LVL78:
 1199 0360 8111      		cpse r24,__zero_reg__
 1200 0362 00C0      		rjmp .L62
 1201               	.LVL79:
 1202               	.LBB14:
 634:RP6Lib/RP6control/RP6ControlLib.c **** 			uint8_t tmp = released_key;
 635:RP6Lib/RP6control/RP6ControlLib.c **** 			released_key = 0;
 1203               		.loc 1 635 0
 1204 0364 1092 0000 		sts released_key.2400,__zero_reg__
 636:RP6Lib/RP6control/RP6ControlLib.c **** 			return tmp;
 1205               		.loc 1 636 0
 1206 0368 8C2F      		mov r24,r28
 1207 036a 00C0      		rjmp .L61
 1208               	.LVL80:
 1209               	.L60:
 1210               	.LBE14:
 637:RP6Lib/RP6control/RP6ControlLib.c **** 		}
 638:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 639:RP6Lib/RP6control/RP6ControlLib.c **** 	else
 640:RP6Lib/RP6control/RP6ControlLib.c **** 		released_key = getPressedKeyNumber();
 1211               		.loc 1 640 0
 1212 036c 0E94 0000 		call getPressedKeyNumber
 1213               	.LVL81:
 1214 0370 8093 0000 		sts released_key.2400,r24
 1215               	.L62:
 641:RP6Lib/RP6control/RP6ControlLib.c **** 	return 0;
 1216               		.loc 1 641 0
 1217 0374 80E0      		ldi r24,0
 1218               	.L61:
 1219               	/* epilogue start */
 642:RP6Lib/RP6control/RP6ControlLib.c **** }
 1220               		.loc 1 642 0
 1221 0376 CF91      		pop r28
 1222 0378 0895      		ret
 1223               		.cfi_endproc
 1224               	.LFE52:
 1226               	.global	__vector_10
 1228               	__vector_10:
 1229               	.LFB55:
 643:RP6Lib/RP6control/RP6ControlLib.c **** 
 644:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 645:RP6Lib/RP6control/RP6ControlLib.c **** // Microphone:
 646:RP6Lib/RP6control/RP6ControlLib.c **** 
 647:RP6Lib/RP6control/RP6ControlLib.c **** /** 
 648:RP6Lib/RP6control/RP6ControlLib.c ****  * This function discharges the Capacitor of the peak detection circuit 
 649:RP6Lib/RP6control/RP6ControlLib.c ****  * used for the Microphone. This is required to remove any previous
 650:RP6Lib/RP6control/RP6ControlLib.c ****  * charge from the capacitor. 
 651:RP6Lib/RP6control/RP6ControlLib.c ****  */
 652:RP6Lib/RP6control/RP6ControlLib.c **** void dischargePeakDetector(void)
 653:RP6Lib/RP6control/RP6ControlLib.c **** {
 654:RP6Lib/RP6control/RP6ControlLib.c **** 	DDRA |= MIC;
 655:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTA &= ~MIC;
 656:RP6Lib/RP6control/RP6ControlLib.c **** 	mSleep(1);
 657:RP6Lib/RP6control/RP6ControlLib.c **** 	DDRA &= ~MIC;
 658:RP6Lib/RP6control/RP6ControlLib.c **** }
 659:RP6Lib/RP6control/RP6ControlLib.c **** 
 660:RP6Lib/RP6control/RP6ControlLib.c **** /**
 661:RP6Lib/RP6control/RP6ControlLib.c ****  * Reads the Microphone peak detector and discharges it afterwards.
 662:RP6Lib/RP6control/RP6ControlLib.c ****  * 
 663:RP6Lib/RP6control/RP6ControlLib.c ****  */
 664:RP6Lib/RP6control/RP6ControlLib.c **** uint16_t getMicrophonePeak(void)
 665:RP6Lib/RP6control/RP6ControlLib.c **** {
 666:RP6Lib/RP6control/RP6ControlLib.c **** 	uint16_t tmp;
 667:RP6Lib/RP6control/RP6ControlLib.c **** 	tmp = readADC(ADC_MIC);
 668:RP6Lib/RP6control/RP6ControlLib.c **** 	if(tmp > 4) 
 669:RP6Lib/RP6control/RP6ControlLib.c **** 		dischargePeakDetector();
 670:RP6Lib/RP6control/RP6ControlLib.c **** 	return tmp;
 671:RP6Lib/RP6control/RP6ControlLib.c **** }
 672:RP6Lib/RP6control/RP6ControlLib.c **** 
 673:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 674:RP6Lib/RP6control/RP6ControlLib.c **** // Delays, Stopwatches and Beeper:
 675:RP6Lib/RP6control/RP6ControlLib.c **** 
 676:RP6Lib/RP6control/RP6ControlLib.c **** 
 677:RP6Lib/RP6control/RP6ControlLib.c **** // ---------------------
 678:RP6Lib/RP6control/RP6ControlLib.c **** // Internal status bits
 679:RP6Lib/RP6control/RP6ControlLib.c **** volatile union {
 680:RP6Lib/RP6control/RP6ControlLib.c **** 	uint8_t byte;
 681:RP6Lib/RP6control/RP6ControlLib.c **** 	struct {
 682:RP6Lib/RP6control/RP6ControlLib.c **** 		unsigned beep:1;
 683:RP6Lib/RP6control/RP6ControlLib.c **** 		unsigned unused:7;
 684:RP6Lib/RP6control/RP6ControlLib.c **** 	};
 685:RP6Lib/RP6control/RP6ControlLib.c **** } controlStatus;
 686:RP6Lib/RP6control/RP6ControlLib.c **** 
 687:RP6Lib/RP6control/RP6ControlLib.c **** volatile stopwatches_t stopwatches;
 688:RP6Lib/RP6control/RP6ControlLib.c **** volatile uint8_t delay_timer;
 689:RP6Lib/RP6control/RP6ControlLib.c **** volatile uint8_t ms_timer;
 690:RP6Lib/RP6control/RP6ControlLib.c **** volatile uint16_t sound_timer;
 691:RP6Lib/RP6control/RP6ControlLib.c **** 
 692:RP6Lib/RP6control/RP6ControlLib.c **** volatile uint16_t timer; // You can use this timer for everything you like!
 693:RP6Lib/RP6control/RP6ControlLib.c **** 
 694:RP6Lib/RP6control/RP6ControlLib.c **** 
 695:RP6Lib/RP6control/RP6ControlLib.c **** /**
 696:RP6Lib/RP6control/RP6ControlLib.c ****  * Timer 0 Compare ISR - This timer is used for various
 697:RP6Lib/RP6control/RP6ControlLib.c ****  * timing stuff: The delay timer for blocking delays, 
 698:RP6Lib/RP6control/RP6ControlLib.c ****  * "Stopwatches" for non-blocking delays and the timing of
 699:RP6Lib/RP6control/RP6ControlLib.c ****  * the sound generation with timer2...
 700:RP6Lib/RP6control/RP6ControlLib.c ****  *
 701:RP6Lib/RP6control/RP6ControlLib.c ****  * By default, it runs at 10kHz which means this ISR is called
 702:RP6Lib/RP6control/RP6ControlLib.c ****  * every ~100s! This is nice for timing stuff!
 703:RP6Lib/RP6control/RP6ControlLib.c ****  */
 704:RP6Lib/RP6control/RP6ControlLib.c **** ISR (TIMER0_COMP_vect)
 705:RP6Lib/RP6control/RP6ControlLib.c **** {
 1230               		.loc 1 705 0
 1231               		.cfi_startproc
 1232 037a 1F92      		push r1
 1233               	.LCFI66:
 1234               		.cfi_def_cfa_offset 3
 1235               		.cfi_offset 1, -2
 1236 037c 0F92      		push r0
 1237               	.LCFI67:
 1238               		.cfi_def_cfa_offset 4
 1239               		.cfi_offset 0, -3
 1240 037e 0FB6      		in r0,__SREG__
 1241 0380 0F92      		push r0
 1242 0382 1124      		clr __zero_reg__
 1243 0384 8F93      		push r24
 1244               	.LCFI68:
 1245               		.cfi_def_cfa_offset 5
 1246               		.cfi_offset 24, -4
 1247 0386 9F93      		push r25
 1248               	.LCFI69:
 1249               		.cfi_def_cfa_offset 6
 1250               		.cfi_offset 25, -5
 1251               	/* prologue: Signal */
 1252               	/* frame size = 0 */
 1253               	/* stack size = 5 */
 1254               	.L__stack_usage = 5
 706:RP6Lib/RP6control/RP6ControlLib.c **** 	// 16bit timer (100s resolution)
 707:RP6Lib/RP6control/RP6ControlLib.c **** 	timer++;
 1255               		.loc 1 707 0
 1256 0388 8091 0000 		lds r24,timer
 1257 038c 9091 0000 		lds r25,timer+1
 1258 0390 0196      		adiw r24,1
 1259 0392 9093 0000 		sts timer+1,r25
 1260 0396 8093 0000 		sts timer,r24
 708:RP6Lib/RP6control/RP6ControlLib.c **** 	
 709:RP6Lib/RP6control/RP6ControlLib.c **** 	// Blocking delay (100s):
 710:RP6Lib/RP6control/RP6ControlLib.c **** 	delay_timer++;
 1261               		.loc 1 710 0
 1262 039a 8091 0000 		lds r24,delay_timer
 1263 039e 8F5F      		subi r24,lo8(-(1))
 1264 03a0 8093 0000 		sts delay_timer,r24
 711:RP6Lib/RP6control/RP6ControlLib.c **** 	
 712:RP6Lib/RP6control/RP6ControlLib.c **** 	// All 1ms based timing stuff
 713:RP6Lib/RP6control/RP6ControlLib.c **** 	if(ms_timer++ >= 10) { // 10 * 100s = 1ms
 1265               		.loc 1 713 0
 1266 03a4 8091 0000 		lds r24,ms_timer
 1267 03a8 91E0      		ldi r25,lo8(1)
 1268 03aa 980F      		add r25,r24
 1269 03ac 9093 0000 		sts ms_timer,r25
 1270 03b0 8A30      		cpi r24,lo8(10)
 1271 03b2 00F4      		brsh .+2
 1272 03b4 00C0      		rjmp .L63
 714:RP6Lib/RP6control/RP6ControlLib.c **** 		// 16bit Stopwatches:
 715:RP6Lib/RP6control/RP6ControlLib.c **** 		if(stopwatches.watches & STOPWATCH1)
 1273               		.loc 1 715 0
 1274 03b6 8091 0000 		lds r24,stopwatches
 1275 03ba 80FF      		sbrs r24,0
 1276 03bc 00C0      		rjmp .L65
 716:RP6Lib/RP6control/RP6ControlLib.c **** 			stopwatches.watch1++;
 1277               		.loc 1 716 0
 1278 03be 8091 0000 		lds r24,stopwatches+1
 1279 03c2 9091 0000 		lds r25,stopwatches+1+1
 1280 03c6 0196      		adiw r24,1
 1281 03c8 9093 0000 		sts stopwatches+1+1,r25
 1282 03cc 8093 0000 		sts stopwatches+1,r24
 1283               	.L65:
 717:RP6Lib/RP6control/RP6ControlLib.c **** 		if(stopwatches.watches & STOPWATCH2)
 1284               		.loc 1 717 0
 1285 03d0 8091 0000 		lds r24,stopwatches
 1286 03d4 81FF      		sbrs r24,1
 1287 03d6 00C0      		rjmp .L66
 718:RP6Lib/RP6control/RP6ControlLib.c **** 			stopwatches.watch2++;
 1288               		.loc 1 718 0
 1289 03d8 8091 0000 		lds r24,stopwatches+3
 1290 03dc 9091 0000 		lds r25,stopwatches+3+1
 1291 03e0 0196      		adiw r24,1
 1292 03e2 9093 0000 		sts stopwatches+3+1,r25
 1293 03e6 8093 0000 		sts stopwatches+3,r24
 1294               	.L66:
 719:RP6Lib/RP6control/RP6ControlLib.c **** 		if(stopwatches.watches & STOPWATCH3)
 1295               		.loc 1 719 0
 1296 03ea 8091 0000 		lds r24,stopwatches
 1297 03ee 82FF      		sbrs r24,2
 1298 03f0 00C0      		rjmp .L67
 720:RP6Lib/RP6control/RP6ControlLib.c **** 			stopwatches.watch3++;
 1299               		.loc 1 720 0
 1300 03f2 8091 0000 		lds r24,stopwatches+5
 1301 03f6 9091 0000 		lds r25,stopwatches+5+1
 1302 03fa 0196      		adiw r24,1
 1303 03fc 9093 0000 		sts stopwatches+5+1,r25
 1304 0400 8093 0000 		sts stopwatches+5,r24
 1305               	.L67:
 721:RP6Lib/RP6control/RP6ControlLib.c **** 		if(stopwatches.watches & STOPWATCH4)
 1306               		.loc 1 721 0
 1307 0404 8091 0000 		lds r24,stopwatches
 1308 0408 83FF      		sbrs r24,3
 1309 040a 00C0      		rjmp .L68
 722:RP6Lib/RP6control/RP6ControlLib.c **** 			stopwatches.watch4++;
 1310               		.loc 1 722 0
 1311 040c 8091 0000 		lds r24,stopwatches+7
 1312 0410 9091 0000 		lds r25,stopwatches+7+1
 1313 0414 0196      		adiw r24,1
 1314 0416 9093 0000 		sts stopwatches+7+1,r25
 1315 041a 8093 0000 		sts stopwatches+7,r24
 1316               	.L68:
 723:RP6Lib/RP6control/RP6ControlLib.c **** 		if(stopwatches.watches & STOPWATCH5)
 1317               		.loc 1 723 0
 1318 041e 8091 0000 		lds r24,stopwatches
 1319 0422 84FF      		sbrs r24,4
 1320 0424 00C0      		rjmp .L69
 724:RP6Lib/RP6control/RP6ControlLib.c **** 			stopwatches.watch5++;
 1321               		.loc 1 724 0
 1322 0426 8091 0000 		lds r24,stopwatches+9
 1323 042a 9091 0000 		lds r25,stopwatches+9+1
 1324 042e 0196      		adiw r24,1
 1325 0430 9093 0000 		sts stopwatches+9+1,r25
 1326 0434 8093 0000 		sts stopwatches+9,r24
 1327               	.L69:
 725:RP6Lib/RP6control/RP6ControlLib.c **** 		if(stopwatches.watches & STOPWATCH6)
 1328               		.loc 1 725 0
 1329 0438 8091 0000 		lds r24,stopwatches
 1330 043c 85FF      		sbrs r24,5
 1331 043e 00C0      		rjmp .L70
 726:RP6Lib/RP6control/RP6ControlLib.c **** 			stopwatches.watch6++;
 1332               		.loc 1 726 0
 1333 0440 8091 0000 		lds r24,stopwatches+11
 1334 0444 9091 0000 		lds r25,stopwatches+11+1
 1335 0448 0196      		adiw r24,1
 1336 044a 9093 0000 		sts stopwatches+11+1,r25
 1337 044e 8093 0000 		sts stopwatches+11,r24
 1338               	.L70:
 727:RP6Lib/RP6control/RP6ControlLib.c **** 		if(stopwatches.watches & STOPWATCH7)
 1339               		.loc 1 727 0
 1340 0452 8091 0000 		lds r24,stopwatches
 1341 0456 86FF      		sbrs r24,6
 1342 0458 00C0      		rjmp .L71
 728:RP6Lib/RP6control/RP6ControlLib.c **** 			stopwatches.watch7++;
 1343               		.loc 1 728 0
 1344 045a 8091 0000 		lds r24,stopwatches+13
 1345 045e 9091 0000 		lds r25,stopwatches+13+1
 1346 0462 0196      		adiw r24,1
 1347 0464 9093 0000 		sts stopwatches+13+1,r25
 1348 0468 8093 0000 		sts stopwatches+13,r24
 1349               	.L71:
 729:RP6Lib/RP6control/RP6ControlLib.c **** 		if(stopwatches.watches & STOPWATCH8)
 1350               		.loc 1 729 0
 1351 046c 8091 0000 		lds r24,stopwatches
 1352 0470 87FF      		sbrs r24,7
 1353 0472 00C0      		rjmp .L72
 730:RP6Lib/RP6control/RP6ControlLib.c **** 			stopwatches.watch8++;
 1354               		.loc 1 730 0
 1355 0474 8091 0000 		lds r24,stopwatches+15
 1356 0478 9091 0000 		lds r25,stopwatches+15+1
 1357 047c 0196      		adiw r24,1
 1358 047e 9093 0000 		sts stopwatches+15+1,r25
 1359 0482 8093 0000 		sts stopwatches+15,r24
 1360               	.L72:
 731:RP6Lib/RP6control/RP6ControlLib.c **** 
 732:RP6Lib/RP6control/RP6ControlLib.c **** 		// Sound generation timing:
 733:RP6Lib/RP6control/RP6ControlLib.c **** 		if(controlStatus.beep) {
 1361               		.loc 1 733 0
 1362 0486 8091 0000 		lds r24,controlStatus
 1363 048a 80FF      		sbrs r24,0
 1364 048c 00C0      		rjmp .L73
 734:RP6Lib/RP6control/RP6ControlLib.c **** 			if(sound_timer < 1) { // sound_timer * 1ms
 1365               		.loc 1 734 0
 1366 048e 8091 0000 		lds r24,sound_timer
 1367 0492 9091 0000 		lds r25,sound_timer+1
 1368 0496 892B      		or r24,r25
 1369 0498 01F4      		brne .L74
 735:RP6Lib/RP6control/RP6ControlLib.c **** 				TCCR2 = 0;
 1370               		.loc 1 735 0
 1371 049a 15BC      		out 0x25,__zero_reg__
 736:RP6Lib/RP6control/RP6ControlLib.c **** 				controlStatus.beep = false;
 1372               		.loc 1 736 0
 1373 049c 8091 0000 		lds r24,controlStatus
 1374 04a0 8E7F      		andi r24,lo8(~(1<<0))
 1375 04a2 8093 0000 		sts controlStatus,r24
 1376 04a6 00C0      		rjmp .L73
 1377               	.L74:
 737:RP6Lib/RP6control/RP6ControlLib.c **** 			}
 738:RP6Lib/RP6control/RP6ControlLib.c **** 			else
 739:RP6Lib/RP6control/RP6ControlLib.c **** 				sound_timer--;
 1378               		.loc 1 739 0
 1379 04a8 8091 0000 		lds r24,sound_timer
 1380 04ac 9091 0000 		lds r25,sound_timer+1
 1381 04b0 0197      		sbiw r24,1
 1382 04b2 9093 0000 		sts sound_timer+1,r25
 1383 04b6 8093 0000 		sts sound_timer,r24
 1384               	.L73:
 740:RP6Lib/RP6control/RP6ControlLib.c **** 		}
 741:RP6Lib/RP6control/RP6ControlLib.c **** 		
 742:RP6Lib/RP6control/RP6ControlLib.c **** 		ms_timer = 0;
 1385               		.loc 1 742 0
 1386 04ba 1092 0000 		sts ms_timer,__zero_reg__
 1387               	.L63:
 1388               	/* epilogue start */
 743:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 744:RP6Lib/RP6control/RP6ControlLib.c **** }
 1389               		.loc 1 744 0
 1390 04be 9F91      		pop r25
 1391 04c0 8F91      		pop r24
 1392 04c2 0F90      		pop r0
 1393 04c4 0FBE      		out __SREG__,r0
 1394 04c6 0F90      		pop r0
 1395 04c8 1F90      		pop r1
 1396 04ca 1895      		reti
 1397               		.cfi_endproc
 1398               	.LFE55:
 1400               	.global	beep
 1402               	beep:
 1403               	.LFB56:
 745:RP6Lib/RP6control/RP6ControlLib.c **** 
 746:RP6Lib/RP6control/RP6ControlLib.c **** 
 747:RP6Lib/RP6control/RP6ControlLib.c **** /**
 748:RP6Lib/RP6control/RP6ControlLib.c ****  * You can use this function to make the beeper beep ;) 
 749:RP6Lib/RP6control/RP6ControlLib.c ****  * But this function should not be used as it does not
 750:RP6Lib/RP6control/RP6ControlLib.c ****  * generate a delay for the sound and a delay between 
 751:RP6Lib/RP6control/RP6ControlLib.c ****  * two sounds. Better is to use the "sound" macro, which
 752:RP6Lib/RP6control/RP6ControlLib.c ****  * uses this function and adds the required delays.
 753:RP6Lib/RP6control/RP6ControlLib.c ****  *
 754:RP6Lib/RP6control/RP6ControlLib.c ****  * "sound(pitch,time,delay)"
 755:RP6Lib/RP6control/RP6ControlLib.c ****  *
 756:RP6Lib/RP6control/RP6ControlLib.c ****  * 0 = lowest frequency
 757:RP6Lib/RP6control/RP6ControlLib.c ****  * 255 = highest frequency
 758:RP6Lib/RP6control/RP6ControlLib.c ****  *
 759:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 760:RP6Lib/RP6control/RP6ControlLib.c ****  * sound(150,50,25);
 761:RP6Lib/RP6control/RP6ControlLib.c ****  * sound(200,50,25);
 762:RP6Lib/RP6control/RP6ControlLib.c ****  *
 763:RP6Lib/RP6control/RP6ControlLib.c ****  * Of course the function "beep" is nice to generate
 764:RP6Lib/RP6control/RP6ControlLib.c ****  * sounds when you need to do other things at the same
 765:RP6Lib/RP6control/RP6ControlLib.c ****  * time... 
 766:RP6Lib/RP6control/RP6ControlLib.c ****  */
 767:RP6Lib/RP6control/RP6ControlLib.c **** void beep(uint8_t pitch, uint16_t time)
 768:RP6Lib/RP6control/RP6ControlLib.c **** {
 1404               		.loc 1 768 0
 1405               		.cfi_startproc
 1406               	.LVL82:
 1407               	/* prologue: function */
 1408               	/* frame size = 0 */
 1409               	/* stack size = 0 */
 1410               	.L__stack_usage = 0
 769:RP6Lib/RP6control/RP6ControlLib.c **** 	controlStatus.beep = true;
 1411               		.loc 1 769 0
 1412 04cc 9091 0000 		lds r25,controlStatus
 1413 04d0 9160      		ori r25,lo8(1<<0)
 1414 04d2 9093 0000 		sts controlStatus,r25
 770:RP6Lib/RP6control/RP6ControlLib.c **** 	sound_timer = time;
 1415               		.loc 1 770 0
 1416 04d6 7093 0000 		sts sound_timer+1,r23
 1417 04da 6093 0000 		sts sound_timer,r22
 771:RP6Lib/RP6control/RP6ControlLib.c **** 	OCR2 = 255-pitch;
 1418               		.loc 1 771 0
 1419 04de 8095      		com r24
 1420               	.LVL83:
 1421 04e0 83BD      		out 0x23,r24
 772:RP6Lib/RP6control/RP6ControlLib.c **** 	TCCR2 =  (1 << WGM21) | (1 << COM20) | (1 << CS22) | (1 << CS21);
 1422               		.loc 1 772 0
 1423 04e2 8EE1      		ldi r24,lo8(30)
 1424               	.LVL84:
 1425 04e4 85BD      		out 0x25,r24
 1426               	.LVL85:
 1427 04e6 0895      		ret
 1428               		.cfi_endproc
 1429               	.LFE56:
 1431               	.global	setBeeperPitch
 1433               	setBeeperPitch:
 1434               	.LFB57:
 773:RP6Lib/RP6control/RP6ControlLib.c **** }
 774:RP6Lib/RP6control/RP6ControlLib.c **** 
 775:RP6Lib/RP6control/RP6ControlLib.c **** /**
 776:RP6Lib/RP6control/RP6ControlLib.c ****  * This function has no timing stuff, but otherwise
 777:RP6Lib/RP6control/RP6ControlLib.c ****  * it has the same effect as "beep". It only sets the pitch
 778:RP6Lib/RP6control/RP6ControlLib.c ****  * and this can be used to generate tone sequences which
 779:RP6Lib/RP6control/RP6ControlLib.c ****  * would sound bad if the beeper turns of for a very short time
 780:RP6Lib/RP6control/RP6ControlLib.c ****  * in between - such as alarm tones or special melodies etc. 
 781:RP6Lib/RP6control/RP6ControlLib.c ****  */
 782:RP6Lib/RP6control/RP6ControlLib.c **** void setBeeperPitch(uint8_t pitch)
 783:RP6Lib/RP6control/RP6ControlLib.c **** {
 1435               		.loc 1 783 0
 1436               		.cfi_startproc
 1437               	.LVL86:
 1438               	/* prologue: function */
 1439               	/* frame size = 0 */
 1440               	/* stack size = 0 */
 1441               	.L__stack_usage = 0
 784:RP6Lib/RP6control/RP6ControlLib.c **** 	controlStatus.beep = false;
 1442               		.loc 1 784 0
 1443 04e8 9091 0000 		lds r25,controlStatus
 1444 04ec 9E7F      		andi r25,lo8(~(1<<0))
 1445 04ee 9093 0000 		sts controlStatus,r25
 785:RP6Lib/RP6control/RP6ControlLib.c **** 	OCR2 = 255-pitch;
 1446               		.loc 1 785 0
 1447 04f2 982F      		mov r25,r24
 1448 04f4 9095      		com r25
 1449 04f6 93BD      		out 0x23,r25
 786:RP6Lib/RP6control/RP6ControlLib.c **** 	if(pitch) 
 1450               		.loc 1 786 0
 1451 04f8 8823      		tst r24
 1452 04fa 01F0      		breq .L101
 787:RP6Lib/RP6control/RP6ControlLib.c **** 		TCCR2 =  (1 << WGM21) | (1 << COM20) | (1 << CS22) | (1 << CS21);	
 1453               		.loc 1 787 0
 1454 04fc 8EE1      		ldi r24,lo8(30)
 1455               	.LVL87:
 1456 04fe 85BD      		out 0x25,r24
 1457 0500 0895      		ret
 1458               	.LVL88:
 1459               	.L101:
 788:RP6Lib/RP6control/RP6ControlLib.c **** 	else 
 789:RP6Lib/RP6control/RP6ControlLib.c **** 		TCCR2 = 0;
 1460               		.loc 1 789 0
 1461 0502 15BC      		out 0x25,__zero_reg__
 1462 0504 0895      		ret
 1463               		.cfi_endproc
 1464               	.LFE57:
 1466               	.global	sleep
 1468               	sleep:
 1469               	.LFB58:
 790:RP6Lib/RP6control/RP6ControlLib.c **** }
 791:RP6Lib/RP6control/RP6ControlLib.c **** 
 792:RP6Lib/RP6control/RP6ControlLib.c **** /**
 793:RP6Lib/RP6control/RP6ControlLib.c ****  * Delay with the help of the 10kHz timer.
 794:RP6Lib/RP6control/RP6ControlLib.c ****  * sleep(10) delays for *about* 1ms! Not exaclty, as we do not use assembly routines
 795:RP6Lib/RP6control/RP6ControlLib.c ****  * anywhere in this library!
 796:RP6Lib/RP6control/RP6ControlLib.c ****  *
 797:RP6Lib/RP6control/RP6ControlLib.c ****  * This is a blocking routine, which means that the processor
 798:RP6Lib/RP6control/RP6ControlLib.c ****  * will loop in this routine and (except for interrupts) the
 799:RP6Lib/RP6control/RP6ControlLib.c ****  * normal program flow is stopped!
 800:RP6Lib/RP6control/RP6ControlLib.c ****  * Thus you should use the Stopwatch functions wherever you can!
 801:RP6Lib/RP6control/RP6ControlLib.c ****  *
 802:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 803:RP6Lib/RP6control/RP6ControlLib.c ****  *		sleep(1); // delay 1 * 100us = 100us = 0.1ms
 804:RP6Lib/RP6control/RP6ControlLib.c ****  *		sleep(10); // delay 10 * 100us = 1000us = 1ms
 805:RP6Lib/RP6control/RP6ControlLib.c ****  *		sleep(100); // delay 100 * 100us = 10000us = 10ms
 806:RP6Lib/RP6control/RP6ControlLib.c ****  *		// The maximum delay is:
 807:RP6Lib/RP6control/RP6ControlLib.c ****  *		sleep(255); // delay 255 * 100us = 25500us = 25.5ms
 808:RP6Lib/RP6control/RP6ControlLib.c ****  */
 809:RP6Lib/RP6control/RP6ControlLib.c **** void sleep(uint8_t time)
 810:RP6Lib/RP6control/RP6ControlLib.c **** {
 1470               		.loc 1 810 0
 1471               		.cfi_startproc
 1472               	.LVL89:
 1473               	/* prologue: function */
 1474               	/* frame size = 0 */
 1475               	/* stack size = 0 */
 1476               	.L__stack_usage = 0
 811:RP6Lib/RP6control/RP6ControlLib.c **** 	delay_timer = 0;
 1477               		.loc 1 811 0
 1478 0506 1092 0000 		sts delay_timer,__zero_reg__
 812:RP6Lib/RP6control/RP6ControlLib.c **** 	while (delay_timer <= time+1);
 1479               		.loc 1 812 0
 1480 050a 90E0      		ldi r25,0
 1481 050c 0196      		adiw r24,1
 1482               	.LVL90:
 1483               	.L105:
 1484               		.loc 1 812 0 is_stmt 0 discriminator 1
 1485 050e 2091 0000 		lds r18,delay_timer
 1486 0512 30E0      		ldi r19,0
 1487 0514 8217      		cp r24,r18
 1488 0516 9307      		cpc r25,r19
 1489 0518 04F4      		brge .L105
 1490               	/* epilogue start */
 813:RP6Lib/RP6control/RP6ControlLib.c **** }
 1491               		.loc 1 813 0 is_stmt 1
 1492 051a 0895      		ret
 1493               		.cfi_endproc
 1494               	.LFE58:
 1496               	.global	mSleep
 1498               	mSleep:
 1499               	.LFB59:
 814:RP6Lib/RP6control/RP6ControlLib.c **** 
 815:RP6Lib/RP6control/RP6ControlLib.c **** /**
 816:RP6Lib/RP6control/RP6ControlLib.c ****  * The same as sleep() but this delays for time*1ms.
 817:RP6Lib/RP6control/RP6ControlLib.c ****  *
 818:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 819:RP6Lib/RP6control/RP6ControlLib.c ****  *      mSleep(100); // delay 100 * 1ms = 100ms = 0.1s
 820:RP6Lib/RP6control/RP6ControlLib.c ****  *		mSleep(1000); // delay 1000 * 1ms = 1000ms = 1s
 821:RP6Lib/RP6control/RP6ControlLib.c ****  *
 822:RP6Lib/RP6control/RP6ControlLib.c ****  */
 823:RP6Lib/RP6control/RP6ControlLib.c **** void mSleep(uint16_t time)
 824:RP6Lib/RP6control/RP6ControlLib.c **** {
 1500               		.loc 1 824 0
 1501               		.cfi_startproc
 1502               	.LVL91:
 1503 051c CF93      		push r28
 1504               	.LCFI70:
 1505               		.cfi_def_cfa_offset 3
 1506               		.cfi_offset 28, -2
 1507 051e DF93      		push r29
 1508               	.LCFI71:
 1509               		.cfi_def_cfa_offset 4
 1510               		.cfi_offset 29, -3
 1511               	/* prologue: function */
 1512               	/* frame size = 0 */
 1513               	/* stack size = 2 */
 1514               	.L__stack_usage = 2
 1515 0520 EC01      		movw r28,r24
 1516               	.LVL92:
 1517               	.L107:
 825:RP6Lib/RP6control/RP6ControlLib.c **** 	while (time--) sleep(10);
 1518               		.loc 1 825 0 discriminator 1
 1519 0522 2097      		sbiw r28,0
 1520 0524 01F0      		breq .L109
 1521               		.loc 1 825 0 is_stmt 0 discriminator 2
 1522 0526 8AE0      		ldi r24,lo8(10)
 1523 0528 0E94 0000 		call sleep
 1524               	.LVL93:
 1525 052c 2197      		sbiw r28,1
 1526               	.LVL94:
 1527 052e 00C0      		rjmp .L107
 1528               	.LVL95:
 1529               	.L109:
 1530               	/* epilogue start */
 826:RP6Lib/RP6control/RP6ControlLib.c **** }
 1531               		.loc 1 826 0 is_stmt 1
 1532 0530 DF91      		pop r29
 1533 0532 CF91      		pop r28
 1534               	.LVL96:
 1535 0534 0895      		ret
 1536               		.cfi_endproc
 1537               	.LFE59:
 1539               	.global	dischargePeakDetector
 1541               	dischargePeakDetector:
 1542               	.LFB53:
 653:RP6Lib/RP6control/RP6ControlLib.c **** 	DDRA |= MIC;
 1543               		.loc 1 653 0
 1544               		.cfi_startproc
 1545               	/* prologue: function */
 1546               	/* frame size = 0 */
 1547               	/* stack size = 0 */
 1548               	.L__stack_usage = 0
 654:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTA &= ~MIC;
 1549               		.loc 1 654 0
 1550 0536 D09A      		sbi 0x1a,0
 655:RP6Lib/RP6control/RP6ControlLib.c **** 	mSleep(1);
 1551               		.loc 1 655 0
 1552 0538 D898      		cbi 0x1b,0
 656:RP6Lib/RP6control/RP6ControlLib.c **** 	DDRA &= ~MIC;
 1553               		.loc 1 656 0
 1554 053a 81E0      		ldi r24,lo8(1)
 1555 053c 90E0      		ldi r25,0
 1556 053e 0E94 0000 		call mSleep
 1557               	.LVL97:
 657:RP6Lib/RP6control/RP6ControlLib.c **** }
 1558               		.loc 1 657 0
 1559 0542 D098      		cbi 0x1a,0
 1560 0544 0895      		ret
 1561               		.cfi_endproc
 1562               	.LFE53:
 1564               	.global	getMicrophonePeak
 1566               	getMicrophonePeak:
 1567               	.LFB54:
 665:RP6Lib/RP6control/RP6ControlLib.c **** 	uint16_t tmp;
 1568               		.loc 1 665 0
 1569               		.cfi_startproc
 1570 0546 CF93      		push r28
 1571               	.LCFI72:
 1572               		.cfi_def_cfa_offset 3
 1573               		.cfi_offset 28, -2
 1574 0548 DF93      		push r29
 1575               	.LCFI73:
 1576               		.cfi_def_cfa_offset 4
 1577               		.cfi_offset 29, -3
 1578 054a 00D0      		rcall .
 1579               	.LCFI74:
 1580               		.cfi_def_cfa_offset 6
 1581 054c CDB7      		in r28,__SP_L__
 1582 054e DEB7      		in r29,__SP_H__
 1583               	.LCFI75:
 1584               		.cfi_def_cfa_register 28
 1585               	/* prologue: function */
 1586               	/* frame size = 2 */
 1587               	/* stack size = 4 */
 1588               	.L__stack_usage = 4
 667:RP6Lib/RP6control/RP6ControlLib.c **** 	if(tmp > 4) 
 1589               		.loc 1 667 0
 1590 0550 80E0      		ldi r24,0
 1591 0552 0E94 0000 		call readADC
 1592               	.LVL98:
 668:RP6Lib/RP6control/RP6ControlLib.c **** 		dischargePeakDetector();
 1593               		.loc 1 668 0
 1594 0556 8530      		cpi r24,5
 1595 0558 9105      		cpc r25,__zero_reg__
 1596 055a 00F0      		brlo .L112
 669:RP6Lib/RP6control/RP6ControlLib.c **** 	return tmp;
 1597               		.loc 1 669 0
 1598 055c 8983      		std Y+1,r24
 1599 055e 9A83      		std Y+2,r25
 1600 0560 0E94 0000 		call dischargePeakDetector
 1601               	.LVL99:
 1602 0564 9A81      		ldd r25,Y+2
 1603 0566 8981      		ldd r24,Y+1
 1604               	.L112:
 1605               	/* epilogue start */
 671:RP6Lib/RP6control/RP6ControlLib.c **** 
 1606               		.loc 1 671 0
 1607 0568 0F90      		pop __tmp_reg__
 1608 056a 0F90      		pop __tmp_reg__
 1609 056c DF91      		pop r29
 1610 056e CF91      		pop r28
 1611 0570 0895      		ret
 1612               		.cfi_endproc
 1613               	.LFE54:
 1615               	.global	delayCycles
 1617               	delayCycles:
 1618               	.LFB60:
 827:RP6Lib/RP6control/RP6ControlLib.c **** 
 828:RP6Lib/RP6control/RP6ControlLib.c **** /**
 829:RP6Lib/RP6control/RP6ControlLib.c ****  * Delay a number of instruction cycles. 
 830:RP6Lib/RP6control/RP6ControlLib.c ****  * No exact delay function! And interrupts can still occur and 
 831:RP6Lib/RP6control/RP6ControlLib.c ****  * add a lot of extra cycles.
 832:RP6Lib/RP6control/RP6ControlLib.c ****  * This function only guarantees to delay for a MINIMAL number
 833:RP6Lib/RP6control/RP6ControlLib.c ****  * of cycles! 
 834:RP6Lib/RP6control/RP6ControlLib.c ****  *
 835:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 836:RP6Lib/RP6control/RP6ControlLib.c ****  * 	delayCycles(1000); // Delays for *about* 1000 instruction cycles
 837:RP6Lib/RP6control/RP6ControlLib.c ****  */
 838:RP6Lib/RP6control/RP6ControlLib.c **** void delayCycles(uint16_t dly)
 839:RP6Lib/RP6control/RP6ControlLib.c **** {
 1619               		.loc 1 839 0
 1620               		.cfi_startproc
 1621               	.LVL100:
 1622               	/* prologue: function */
 1623               	/* frame size = 0 */
 1624               	/* stack size = 0 */
 1625               	.L__stack_usage = 0
 1626               	.L114:
 840:RP6Lib/RP6control/RP6ControlLib.c **** 	while(dly--) nop();
 1627               		.loc 1 840 0 discriminator 1
 1628               	.LVL101:
 1629 0572 0197      		sbiw r24,1
 1630 0574 00F0      		brcs .L116
 1631               		.loc 1 840 0 is_stmt 0 discriminator 2
 1632               	/* #APP */
 1633               	 ;  840 "RP6Lib/RP6control/RP6ControlLib.c" 1
 1634 0576 0000      		nop
 1635               		
 1636               	 ;  0 "" 2
 1637               	/* #NOAPP */
 1638 0578 00C0      		rjmp .L114
 1639               	.L116:
 1640               	/* epilogue start */
 841:RP6Lib/RP6control/RP6ControlLib.c **** }
 1641               		.loc 1 841 0 is_stmt 1
 1642 057a 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE60:
 1646               	.global	setLCDD
 1648               	setLCDD:
 1649               	.LFB36:
 324:RP6Lib/RP6control/RP6ControlLib.c **** 	externalPort.LCDD = lcdd;
 1650               		.loc 1 324 0
 1651               		.cfi_startproc
 1652               	.LVL102:
 1653               	/* prologue: function */
 1654               	/* frame size = 0 */
 1655               	/* stack size = 0 */
 1656               	.L__stack_usage = 0
 325:RP6Lib/RP6control/RP6ControlLib.c **** 	outputExt();
 1657               		.loc 1 325 0
 1658 057c 8295      		swap r24
 1659               	.LVL103:
 1660 057e 807F      		andi r24,lo8(-16)
 1661 0580 9091 0000 		lds r25,externalPort
 1662 0584 9F70      		andi r25,lo8(15)
 1663 0586 982B      		or r25,r24
 1664 0588 9093 0000 		sts externalPort,r25
 326:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= LCD_EN;
 1665               		.loc 1 326 0
 1666 058c 0E94 0000 		call outputExt
 1667               	.LVL104:
 327:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(50);
 1668               		.loc 1 327 0
 1669 0590 C49A      		sbi 0x18,4
 328:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~LCD_EN;
 1670               		.loc 1 328 0
 1671 0592 82E3      		ldi r24,lo8(50)
 1672 0594 90E0      		ldi r25,0
 1673 0596 0E94 0000 		call delayCycles
 1674               	.LVL105:
 329:RP6Lib/RP6control/RP6ControlLib.c **** }
 1675               		.loc 1 329 0
 1676 059a C498      		cbi 0x18,4
 1677 059c 0895      		ret
 1678               		.cfi_endproc
 1679               	.LFE36:
 1681               	.global	write4BitLCDData
 1683               	write4BitLCDData:
 1684               	.LFB38:
 364:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(data >> 4);
 1685               		.loc 1 364 0
 1686               		.cfi_startproc
 1687               	.LVL106:
 1688 059e CF93      		push r28
 1689               	.LCFI76:
 1690               		.cfi_def_cfa_offset 3
 1691               		.cfi_offset 28, -2
 1692               	/* prologue: function */
 1693               	/* frame size = 0 */
 1694               	/* stack size = 1 */
 1695               	.L__stack_usage = 1
 1696 05a0 C82F      		mov r28,r24
 365:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(data);
 1697               		.loc 1 365 0
 1698 05a2 8295      		swap r24
 1699               	.LVL107:
 1700 05a4 8F70      		andi r24,lo8(15)
 1701 05a6 0E94 0000 		call setLCDD
 1702               	.LVL108:
 366:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(150);
 1703               		.loc 1 366 0
 1704 05aa 8C2F      		mov r24,r28
 1705 05ac 0E94 0000 		call setLCDD
 1706               	.LVL109:
 367:RP6Lib/RP6control/RP6ControlLib.c **** }
 1707               		.loc 1 367 0
 1708 05b0 86E9      		ldi r24,lo8(-106)
 1709 05b2 90E0      		ldi r25,0
 1710               	/* epilogue start */
 368:RP6Lib/RP6control/RP6ControlLib.c **** 
 1711               		.loc 1 368 0
 1712 05b4 CF91      		pop r28
 1713               	.LVL110:
 367:RP6Lib/RP6control/RP6ControlLib.c **** }
 1714               		.loc 1 367 0
 1715 05b6 0C94 0000 		jmp delayCycles
 1716               	.LVL111:
 1717               		.cfi_endproc
 1718               	.LFE38:
 1720               	.global	writeLCDCommand
 1722               	writeLCDCommand:
 1723               	.LFB39:
 374:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB &= ~LCD_RS;
 1724               		.loc 1 374 0
 1725               		.cfi_startproc
 1726               	.LVL112:
 1727               	/* prologue: function */
 1728               	/* frame size = 0 */
 1729               	/* stack size = 0 */
 1730               	.L__stack_usage = 0
 375:RP6Lib/RP6control/RP6ControlLib.c **** 	write4BitLCDData(cmd);
 1731               		.loc 1 375 0
 1732 05ba C398      		cbi 0x18,3
 376:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(150);
 1733               		.loc 1 376 0
 1734 05bc 0E94 0000 		call write4BitLCDData
 1735               	.LVL113:
 377:RP6Lib/RP6control/RP6ControlLib.c **** }
 1736               		.loc 1 377 0
 1737 05c0 86E9      		ldi r24,lo8(-106)
 1738 05c2 90E0      		ldi r25,0
 1739 05c4 0C94 0000 		jmp delayCycles
 1740               	.LVL114:
 1741               		.cfi_endproc
 1742               	.LFE39:
 1744               	.global	setCursorPosLCD
 1746               	setCursorPosLCD:
 1747               	.LFB48:
 543:RP6Lib/RP6control/RP6ControlLib.c **** 	pos |= 128;
 1748               		.loc 1 543 0
 1749               		.cfi_startproc
 1750               	.LVL115:
 1751               	/* prologue: function */
 1752               	/* frame size = 0 */
 1753               	/* stack size = 0 */
 1754               	.L__stack_usage = 0
 544:RP6Lib/RP6control/RP6ControlLib.c **** 	if(line==1) pos += 0x40;
 1755               		.loc 1 544 0
 1756 05c8 6068      		ori r22,lo8(-128)
 1757               	.LVL116:
 545:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(pos);
 1758               		.loc 1 545 0
 1759 05ca 8130      		cpi r24,lo8(1)
 1760 05cc 01F4      		brne .L121
 545:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(pos);
 1761               		.loc 1 545 0 is_stmt 0 discriminator 1
 1762 05ce 605C      		subi r22,lo8(-(64))
 1763               	.LVL117:
 1764               	.L121:
 546:RP6Lib/RP6control/RP6ControlLib.c **** }
 1765               		.loc 1 546 0 is_stmt 1
 1766 05d0 862F      		mov r24,r22
 1767               	.LVL118:
 1768 05d2 0C94 0000 		jmp writeLCDCommand
 1769               	.LVL119:
 1770               		.cfi_endproc
 1771               	.LFE48:
 1773               	.global	initLCD
 1775               	initLCD:
 1776               	.LFB37:
 337:RP6Lib/RP6control/RP6ControlLib.c **** 	//delayCycles(34000); No need for Power ON delay as usually the
 1777               		.loc 1 337 0
 1778               		.cfi_startproc
 1779               	/* prologue: function */
 1780               	/* frame size = 0 */
 1781               	/* stack size = 0 */
 1782               	.L__stack_usage = 0
 340:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(18000);
 1783               		.loc 1 340 0
 1784 05d6 83E0      		ldi r24,lo8(3)
 1785 05d8 0E94 0000 		call setLCDD
 1786               	.LVL120:
 341:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(0b0011);
 1787               		.loc 1 341 0
 1788 05dc 80E5      		ldi r24,lo8(80)
 1789 05de 96E4      		ldi r25,lo8(70)
 1790 05e0 0E94 0000 		call delayCycles
 1791               	.LVL121:
 342:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1792               		.loc 1 342 0
 1793 05e4 83E0      		ldi r24,lo8(3)
 1794 05e6 0E94 0000 		call setLCDD
 1795               	.LVL122:
 343:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(0b0011);
 1796               		.loc 1 343 0
 1797 05ea 8CE7      		ldi r24,lo8(124)
 1798 05ec 95E1      		ldi r25,lo8(21)
 1799 05ee 0E94 0000 		call delayCycles
 1800               	.LVL123:
 344:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1801               		.loc 1 344 0
 1802 05f2 83E0      		ldi r24,lo8(3)
 1803 05f4 0E94 0000 		call setLCDD
 1804               	.LVL124:
 345:RP6Lib/RP6control/RP6ControlLib.c **** 	setLCDD(0b0010);
 1805               		.loc 1 345 0
 1806 05f8 8CE7      		ldi r24,lo8(124)
 1807 05fa 95E1      		ldi r25,lo8(21)
 1808 05fc 0E94 0000 		call delayCycles
 1809               	.LVL125:
 346:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1810               		.loc 1 346 0
 1811 0600 82E0      		ldi r24,lo8(2)
 1812 0602 0E94 0000 		call setLCDD
 1813               	.LVL126:
 347:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00101000);
 1814               		.loc 1 347 0
 1815 0606 8CE7      		ldi r24,lo8(124)
 1816 0608 95E1      		ldi r25,lo8(21)
 1817 060a 0E94 0000 		call delayCycles
 1818               	.LVL127:
 348:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1819               		.loc 1 348 0
 1820 060e 88E2      		ldi r24,lo8(40)
 1821 0610 0E94 0000 		call writeLCDCommand
 1822               	.LVL128:
 349:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00001000);
 1823               		.loc 1 349 0
 1824 0614 8CE7      		ldi r24,lo8(124)
 1825 0616 95E1      		ldi r25,lo8(21)
 1826 0618 0E94 0000 		call delayCycles
 1827               	.LVL129:
 350:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1828               		.loc 1 350 0
 1829 061c 88E0      		ldi r24,lo8(8)
 1830 061e 0E94 0000 		call writeLCDCommand
 1831               	.LVL130:
 351:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00000001);
 1832               		.loc 1 351 0
 1833 0622 8CE7      		ldi r24,lo8(124)
 1834 0624 95E1      		ldi r25,lo8(21)
 1835 0626 0E94 0000 		call delayCycles
 1836               	.LVL131:
 352:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1837               		.loc 1 352 0
 1838 062a 81E0      		ldi r24,lo8(1)
 1839 062c 0E94 0000 		call writeLCDCommand
 1840               	.LVL132:
 353:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00000010);
 1841               		.loc 1 353 0
 1842 0630 8CE7      		ldi r24,lo8(124)
 1843 0632 95E1      		ldi r25,lo8(21)
 1844 0634 0E94 0000 		call delayCycles
 1845               	.LVL133:
 354:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1846               		.loc 1 354 0
 1847 0638 82E0      		ldi r24,lo8(2)
 1848 063a 0E94 0000 		call writeLCDCommand
 1849               	.LVL134:
 355:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00001100);
 1850               		.loc 1 355 0
 1851 063e 8CE7      		ldi r24,lo8(124)
 1852 0640 95E1      		ldi r25,lo8(21)
 1853 0642 0E94 0000 		call delayCycles
 1854               	.LVL135:
 356:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1855               		.loc 1 356 0
 1856 0646 8CE0      		ldi r24,lo8(12)
 1857 0648 0E94 0000 		call writeLCDCommand
 1858               	.LVL136:
 357:RP6Lib/RP6control/RP6ControlLib.c **** }
 1859               		.loc 1 357 0
 1860 064c 8CE7      		ldi r24,lo8(124)
 1861 064e 95E1      		ldi r25,lo8(21)
 1862 0650 0C94 0000 		jmp delayCycles
 1863               	.LVL137:
 1864               		.cfi_endproc
 1865               	.LFE37:
 1867               	.global	clearLCD
 1869               	clearLCD:
 1870               	.LFB40:
 384:RP6Lib/RP6control/RP6ControlLib.c **** 	writeLCDCommand(0b00000001);
 1871               		.loc 1 384 0
 1872               		.cfi_startproc
 1873               	/* prologue: function */
 1874               	/* frame size = 0 */
 1875               	/* stack size = 0 */
 1876               	.L__stack_usage = 0
 385:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(5500);
 1877               		.loc 1 385 0
 1878 0654 81E0      		ldi r24,lo8(1)
 1879 0656 0E94 0000 		call writeLCDCommand
 1880               	.LVL138:
 386:RP6Lib/RP6control/RP6ControlLib.c **** }
 1881               		.loc 1 386 0
 1882 065a 8CE7      		ldi r24,lo8(124)
 1883 065c 95E1      		ldi r25,lo8(21)
 1884 065e 0C94 0000 		jmp delayCycles
 1885               	.LVL139:
 1886               		.cfi_endproc
 1887               	.LFE40:
 1889               	.global	writeCharLCD
 1891               	writeCharLCD:
 1892               	.LFB41:
 413:RP6Lib/RP6control/RP6ControlLib.c **** 	PORTB |= LCD_RS;
 1893               		.loc 1 413 0
 1894               		.cfi_startproc
 1895               	.LVL140:
 1896               	/* prologue: function */
 1897               	/* frame size = 0 */
 1898               	/* stack size = 0 */
 1899               	.L__stack_usage = 0
 414:RP6Lib/RP6control/RP6ControlLib.c **** 	write4BitLCDData(ch);
 1900               		.loc 1 414 0
 1901 0662 C39A      		sbi 0x18,3
 415:RP6Lib/RP6control/RP6ControlLib.c **** 	delayCycles(50);
 1902               		.loc 1 415 0
 1903 0664 0E94 0000 		call write4BitLCDData
 1904               	.LVL141:
 416:RP6Lib/RP6control/RP6ControlLib.c **** }
 1905               		.loc 1 416 0
 1906 0668 82E3      		ldi r24,lo8(50)
 1907 066a 90E0      		ldi r25,0
 1908 066c 0C94 0000 		jmp delayCycles
 1909               	.LVL142:
 1910               		.cfi_endproc
 1911               	.LFE41:
 1913               	.global	writeNStringLCD_P
 1915               	writeNStringLCD_P:
 1916               	.LFB42:
 434:RP6Lib/RP6control/RP6ControlLib.c ****     uint8_t c;
 1917               		.loc 1 434 0
 1918               		.cfi_startproc
 1919               	.LVL143:
 1920 0670 CF93      		push r28
 1921               	.LCFI77:
 1922               		.cfi_def_cfa_offset 3
 1923               		.cfi_offset 28, -2
 1924 0672 DF93      		push r29
 1925               	.LCFI78:
 1926               		.cfi_def_cfa_offset 4
 1927               		.cfi_offset 29, -3
 1928               	/* prologue: function */
 1929               	/* frame size = 0 */
 1930               	/* stack size = 2 */
 1931               	.L__stack_usage = 2
 1932 0674 FC01      		movw r30,r24
 1933               	.LVL144:
 1934               	.L126:
 1935               	.LBB15:
 436:RP6Lib/RP6control/RP6ControlLib.c **** }
 1936               		.loc 1 436 0 discriminator 1
 1937               	/* #APP */
 1938               	 ;  436 "RP6Lib/RP6control/RP6ControlLib.c" 1
 1939 0676 8491      		lpm r24, Z
 1940               		
 1941               	 ;  0 "" 2
 1942               	.LVL145:
 1943               	/* #NOAPP */
 1944 0678 EF01      		movw r28,r30
 1945 067a 2196      		adiw r28,1
 1946               	.LVL146:
 1947               	.LBE15:
 1948 067c 8823      		tst r24
 1949 067e 01F0      		breq .L128
 436:RP6Lib/RP6control/RP6ControlLib.c **** }
 1950               		.loc 1 436 0 is_stmt 0 discriminator 2
 1951 0680 0E94 0000 		call writeCharLCD
 1952               	.LVL147:
 1953 0684 FE01      		movw r30,r28
 1954 0686 00C0      		rjmp .L126
 1955               	.LVL148:
 1956               	.L128:
 1957               	/* epilogue start */
 437:RP6Lib/RP6control/RP6ControlLib.c **** 
 1958               		.loc 1 437 0 is_stmt 1
 1959 0688 DF91      		pop r29
 1960 068a CF91      		pop r28
 1961               	.LVL149:
 1962 068c 0895      		ret
 1963               		.cfi_endproc
 1964               	.LFE42:
 1966               	.global	_showScreenLCD_P
 1968               	_showScreenLCD_P:
 1969               	.LFB47:
 532:RP6Lib/RP6control/RP6ControlLib.c **** 	clearLCD();
 1970               		.loc 1 532 0
 1971               		.cfi_startproc
 1972               	.LVL150:
 1973 068e 0F93      		push r16
 1974               	.LCFI79:
 1975               		.cfi_def_cfa_offset 3
 1976               		.cfi_offset 16, -2
 1977 0690 1F93      		push r17
 1978               	.LCFI80:
 1979               		.cfi_def_cfa_offset 4
 1980               		.cfi_offset 17, -3
 1981 0692 CF93      		push r28
 1982               	.LCFI81:
 1983               		.cfi_def_cfa_offset 5
 1984               		.cfi_offset 28, -4
 1985 0694 DF93      		push r29
 1986               	.LCFI82:
 1987               		.cfi_def_cfa_offset 6
 1988               		.cfi_offset 29, -5
 1989 0696 00D0      		rcall .
 1990               	.LCFI83:
 1991               		.cfi_def_cfa_offset 8
 1992 0698 CDB7      		in r28,__SP_L__
 1993 069a DEB7      		in r29,__SP_H__
 1994               	.LCFI84:
 1995               		.cfi_def_cfa_register 28
 1996               	/* prologue: function */
 1997               	/* frame size = 2 */
 1998               	/* stack size = 6 */
 1999               	.L__stack_usage = 6
 2000 069c 8B01      		movw r16,r22
 533:RP6Lib/RP6control/RP6ControlLib.c **** 	writeNStringLCD_P(line1);
 2001               		.loc 1 533 0
 2002 069e 8983      		std Y+1,r24
 2003 06a0 9A83      		std Y+2,r25
 2004 06a2 0E94 0000 		call clearLCD
 2005               	.LVL151:
 534:RP6Lib/RP6control/RP6ControlLib.c **** 	setCursorPosLCD(1, 0);
 2006               		.loc 1 534 0
 2007 06a6 8981      		ldd r24,Y+1
 2008 06a8 9A81      		ldd r25,Y+2
 2009 06aa 0E94 0000 		call writeNStringLCD_P
 2010               	.LVL152:
 2011               	.LBB18:
 2012               	.LBB19:
 546:RP6Lib/RP6control/RP6ControlLib.c **** }
 2013               		.loc 1 546 0
 2014 06ae 80EC      		ldi r24,lo8(-64)
 2015 06b0 0E94 0000 		call writeLCDCommand
 2016               	.LVL153:
 2017               	.LBE19:
 2018               	.LBE18:
 536:RP6Lib/RP6control/RP6ControlLib.c **** }
 2019               		.loc 1 536 0
 2020 06b4 C801      		movw r24,r16
 2021               	/* epilogue start */
 537:RP6Lib/RP6control/RP6ControlLib.c **** 
 2022               		.loc 1 537 0
 2023 06b6 0F90      		pop __tmp_reg__
 2024 06b8 0F90      		pop __tmp_reg__
 2025 06ba DF91      		pop r29
 2026 06bc CF91      		pop r28
 2027 06be 1F91      		pop r17
 2028 06c0 0F91      		pop r16
 2029               	.LVL154:
 536:RP6Lib/RP6control/RP6ControlLib.c **** }
 2030               		.loc 1 536 0
 2031 06c2 0C94 0000 		jmp writeNStringLCD_P
 2032               	.LVL155:
 2033               		.cfi_endproc
 2034               	.LFE47:
 2036               	.global	writeStringLCD
 2038               	writeStringLCD:
 2039               	.LFB43:
 443:RP6Lib/RP6control/RP6ControlLib.c **** 	while(*string)
 2040               		.loc 1 443 0
 2041               		.cfi_startproc
 2042               	.LVL156:
 2043 06c6 CF93      		push r28
 2044               	.LCFI85:
 2045               		.cfi_def_cfa_offset 3
 2046               		.cfi_offset 28, -2
 2047 06c8 DF93      		push r29
 2048               	.LCFI86:
 2049               		.cfi_def_cfa_offset 4
 2050               		.cfi_offset 29, -3
 2051               	/* prologue: function */
 2052               	/* frame size = 0 */
 2053               	/* stack size = 2 */
 2054               	.L__stack_usage = 2
 2055 06ca EC01      		movw r28,r24
 2056               	.LVL157:
 2057               	.L131:
 444:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(*string++);
 2058               		.loc 1 444 0 discriminator 1
 2059 06cc 8991      		ld r24,Y+
 2060               	.LVL158:
 2061 06ce 8823      		tst r24
 2062 06d0 01F0      		breq .L133
 2063               	.LVL159:
 445:RP6Lib/RP6control/RP6ControlLib.c **** }
 2064               		.loc 1 445 0
 2065 06d2 0E94 0000 		call writeCharLCD
 2066               	.LVL160:
 2067 06d6 00C0      		rjmp .L131
 2068               	.LVL161:
 2069               	.L133:
 2070               	/* epilogue start */
 446:RP6Lib/RP6control/RP6ControlLib.c **** 
 2071               		.loc 1 446 0
 2072 06d8 DF91      		pop r29
 2073 06da CF91      		pop r28
 2074               	.LVL162:
 2075 06dc 0895      		ret
 2076               		.cfi_endproc
 2077               	.LFE43:
 2079               	.global	writeIntegerLCD
 2081               	writeIntegerLCD:
 2082               	.LFB45:
 489:RP6Lib/RP6control/RP6ControlLib.c **** 	itoa(number, &lcd_tmp_buffer[0], base);
 2083               		.loc 1 489 0
 2084               		.cfi_startproc
 2085               	.LVL163:
 2086               	/* prologue: function */
 2087               	/* frame size = 0 */
 2088               	/* stack size = 0 */
 2089               	.L__stack_usage = 0
 490:RP6Lib/RP6control/RP6ControlLib.c **** 	writeStringLCD(&lcd_tmp_buffer[0]);
 2090               		.loc 1 490 0
 2091 06de 462F      		mov r20,r22
 2092 06e0 50E0      		ldi r21,0
 2093               	.LBB20:
 2094               	.LBB21:
 2095               		.file 2 "d:\\development\\rp6\\avr\\include\\stdlib.h"
   1:d:\development\rp6\avr\include\stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\development\rp6\avr\include\stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:d:\development\rp6\avr\include\stdlib.h **** 
   4:d:\development\rp6\avr\include\stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:d:\development\rp6\avr\include\stdlib.h ****    The Regents of the University of California.
   6:d:\development\rp6\avr\include\stdlib.h **** 
   7:d:\development\rp6\avr\include\stdlib.h ****    All rights reserved.
   8:d:\development\rp6\avr\include\stdlib.h **** 
   9:d:\development\rp6\avr\include\stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:d:\development\rp6\avr\include\stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:d:\development\rp6\avr\include\stdlib.h **** 
  12:d:\development\rp6\avr\include\stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:d:\development\rp6\avr\include\stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:d:\development\rp6\avr\include\stdlib.h **** 
  15:d:\development\rp6\avr\include\stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:d:\development\rp6\avr\include\stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:d:\development\rp6\avr\include\stdlib.h ****      the documentation and/or other materials provided with the
  18:d:\development\rp6\avr\include\stdlib.h ****      distribution.
  19:d:\development\rp6\avr\include\stdlib.h **** 
  20:d:\development\rp6\avr\include\stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:d:\development\rp6\avr\include\stdlib.h ****      contributors may be used to endorse or promote products derived
  22:d:\development\rp6\avr\include\stdlib.h ****      from this software without specific prior written permission.
  23:d:\development\rp6\avr\include\stdlib.h **** 
  24:d:\development\rp6\avr\include\stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:d:\development\rp6\avr\include\stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:d:\development\rp6\avr\include\stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:d:\development\rp6\avr\include\stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:d:\development\rp6\avr\include\stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:d:\development\rp6\avr\include\stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:d:\development\rp6\avr\include\stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:d:\development\rp6\avr\include\stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:d:\development\rp6\avr\include\stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:d:\development\rp6\avr\include\stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:d:\development\rp6\avr\include\stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:d:\development\rp6\avr\include\stdlib.h **** 
  36:d:\development\rp6\avr\include\stdlib.h ****   $Id: stdlib.h 2301 2012-11-16 21:06:44Z arcanum $
  37:d:\development\rp6\avr\include\stdlib.h **** */
  38:d:\development\rp6\avr\include\stdlib.h **** 
  39:d:\development\rp6\avr\include\stdlib.h **** #ifndef _STDLIB_H_
  40:d:\development\rp6\avr\include\stdlib.h **** #define	_STDLIB_H_ 1
  41:d:\development\rp6\avr\include\stdlib.h **** 
  42:d:\development\rp6\avr\include\stdlib.h **** #ifndef __ASSEMBLER__
  43:d:\development\rp6\avr\include\stdlib.h **** 
  44:d:\development\rp6\avr\include\stdlib.h **** #define __need_NULL
  45:d:\development\rp6\avr\include\stdlib.h **** #define __need_size_t
  46:d:\development\rp6\avr\include\stdlib.h **** #define __need_wchar_t
  47:d:\development\rp6\avr\include\stdlib.h **** #include <stddef.h>
  48:d:\development\rp6\avr\include\stdlib.h **** 
  49:d:\development\rp6\avr\include\stdlib.h **** #ifndef __ptr_t
  50:d:\development\rp6\avr\include\stdlib.h **** #define __ptr_t void *
  51:d:\development\rp6\avr\include\stdlib.h **** #endif
  52:d:\development\rp6\avr\include\stdlib.h **** 
  53:d:\development\rp6\avr\include\stdlib.h **** #ifdef __cplusplus
  54:d:\development\rp6\avr\include\stdlib.h **** extern "C" {
  55:d:\development\rp6\avr\include\stdlib.h **** #endif
  56:d:\development\rp6\avr\include\stdlib.h **** 
  57:d:\development\rp6\avr\include\stdlib.h **** /** \file */
  58:d:\development\rp6\avr\include\stdlib.h **** 
  59:d:\development\rp6\avr\include\stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  60:d:\development\rp6\avr\include\stdlib.h ****     \code #include <stdlib.h> \endcode
  61:d:\development\rp6\avr\include\stdlib.h **** 
  62:d:\development\rp6\avr\include\stdlib.h ****     This file declares some basic C macros and functions as
  63:d:\development\rp6\avr\include\stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  64:d:\development\rp6\avr\include\stdlib.h **** */
  65:d:\development\rp6\avr\include\stdlib.h **** 
  66:d:\development\rp6\avr\include\stdlib.h **** /*@{*/
  67:d:\development\rp6\avr\include\stdlib.h **** /** Result type for function div(). */
  68:d:\development\rp6\avr\include\stdlib.h **** typedef struct {
  69:d:\development\rp6\avr\include\stdlib.h **** 	int quot;                   /**< The Quotient. */
  70:d:\development\rp6\avr\include\stdlib.h **** 	int rem;                    /**< The Remainder. */
  71:d:\development\rp6\avr\include\stdlib.h **** } div_t;
  72:d:\development\rp6\avr\include\stdlib.h **** 
  73:d:\development\rp6\avr\include\stdlib.h **** /** Result type for function ldiv(). */
  74:d:\development\rp6\avr\include\stdlib.h **** typedef struct {
  75:d:\development\rp6\avr\include\stdlib.h **** 	long quot;                  /**< The Quotient. */
  76:d:\development\rp6\avr\include\stdlib.h **** 	long rem;                   /**< The Remainder. */
  77:d:\development\rp6\avr\include\stdlib.h **** } ldiv_t;
  78:d:\development\rp6\avr\include\stdlib.h **** 
  79:d:\development\rp6\avr\include\stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  80:d:\development\rp6\avr\include\stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  81:d:\development\rp6\avr\include\stdlib.h **** 
  82:d:\development\rp6\avr\include\stdlib.h **** #ifndef __DOXYGEN__
  83:d:\development\rp6\avr\include\stdlib.h **** 
  84:d:\development\rp6\avr\include\stdlib.h **** #ifndef __ATTR_CONST__
  85:d:\development\rp6\avr\include\stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  86:d:\development\rp6\avr\include\stdlib.h **** #endif
  87:d:\development\rp6\avr\include\stdlib.h **** 
  88:d:\development\rp6\avr\include\stdlib.h **** #ifndef __ATTR_MALLOC__
  89:d:\development\rp6\avr\include\stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  90:d:\development\rp6\avr\include\stdlib.h **** #endif
  91:d:\development\rp6\avr\include\stdlib.h **** 
  92:d:\development\rp6\avr\include\stdlib.h **** #ifndef __ATTR_NORETURN__
  93:d:\development\rp6\avr\include\stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  94:d:\development\rp6\avr\include\stdlib.h **** #endif
  95:d:\development\rp6\avr\include\stdlib.h **** 
  96:d:\development\rp6\avr\include\stdlib.h **** #ifndef __ATTR_PURE__
  97:d:\development\rp6\avr\include\stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
  98:d:\development\rp6\avr\include\stdlib.h **** #endif
  99:d:\development\rp6\avr\include\stdlib.h **** 
 100:d:\development\rp6\avr\include\stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 101:d:\development\rp6\avr\include\stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 102:d:\development\rp6\avr\include\stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 103:d:\development\rp6\avr\include\stdlib.h **** # else
 104:d:\development\rp6\avr\include\stdlib.h **** #  define __ATTR_GNU_INLINE__
 105:d:\development\rp6\avr\include\stdlib.h **** # endif
 106:d:\development\rp6\avr\include\stdlib.h **** #endif
 107:d:\development\rp6\avr\include\stdlib.h **** 
 108:d:\development\rp6\avr\include\stdlib.h **** #endif
 109:d:\development\rp6\avr\include\stdlib.h **** 
 110:d:\development\rp6\avr\include\stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 111:d:\development\rp6\avr\include\stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 112:d:\development\rp6\avr\include\stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 113:d:\development\rp6\avr\include\stdlib.h ****     effectively halted by entering an infinite loop. */
 114:d:\development\rp6\avr\include\stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 115:d:\development\rp6\avr\include\stdlib.h **** 
 116:d:\development\rp6\avr\include\stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 117:d:\development\rp6\avr\include\stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 118:d:\development\rp6\avr\include\stdlib.h **** */
 119:d:\development\rp6\avr\include\stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 120:d:\development\rp6\avr\include\stdlib.h **** #ifndef __DOXYGEN__
 121:d:\development\rp6\avr\include\stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 122:d:\development\rp6\avr\include\stdlib.h **** #endif
 123:d:\development\rp6\avr\include\stdlib.h **** 
 124:d:\development\rp6\avr\include\stdlib.h **** /** The labs() function computes the absolute value of the long integer
 125:d:\development\rp6\avr\include\stdlib.h ****     \c i.
 126:d:\development\rp6\avr\include\stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 127:d:\development\rp6\avr\include\stdlib.h **** */
 128:d:\development\rp6\avr\include\stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 129:d:\development\rp6\avr\include\stdlib.h **** #ifndef __DOXYGEN__
 130:d:\development\rp6\avr\include\stdlib.h **** #define labs(__i) __builtin_labs(__i)
 131:d:\development\rp6\avr\include\stdlib.h **** #endif
 132:d:\development\rp6\avr\include\stdlib.h **** 
 133:d:\development\rp6\avr\include\stdlib.h **** /**
 134:d:\development\rp6\avr\include\stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 135:d:\development\rp6\avr\include\stdlib.h ****      initial member of which is pointed to by \c base, for a member
 136:d:\development\rp6\avr\include\stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 137:d:\development\rp6\avr\include\stdlib.h ****      member of the array is specified by \c size.
 138:d:\development\rp6\avr\include\stdlib.h **** 
 139:d:\development\rp6\avr\include\stdlib.h ****      The contents of the array should be in ascending sorted order
 140:d:\development\rp6\avr\include\stdlib.h ****      according to the comparison function referenced by \c compar.
 141:d:\development\rp6\avr\include\stdlib.h ****      The \c compar routine is expected to have two arguments which
 142:d:\development\rp6\avr\include\stdlib.h ****      point to the key object and to an array member, in that order,
 143:d:\development\rp6\avr\include\stdlib.h ****      and should return an integer less than, equal to, or greater than
 144:d:\development\rp6\avr\include\stdlib.h ****      zero if the key object is found, respectively, to be less than,
 145:d:\development\rp6\avr\include\stdlib.h ****      to match, or be greater than the array member.
 146:d:\development\rp6\avr\include\stdlib.h **** 
 147:d:\development\rp6\avr\include\stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 148:d:\development\rp6\avr\include\stdlib.h ****      the array, or a null pointer if no match is found.  If two
 149:d:\development\rp6\avr\include\stdlib.h ****      members compare as equal, which member is matched is unspecified.
 150:d:\development\rp6\avr\include\stdlib.h **** */
 151:d:\development\rp6\avr\include\stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 152:d:\development\rp6\avr\include\stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 153:d:\development\rp6\avr\include\stdlib.h **** 
 154:d:\development\rp6\avr\include\stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 155:d:\development\rp6\avr\include\stdlib.h **** /**
 156:d:\development\rp6\avr\include\stdlib.h ****      The div() function computes the value \c num/denom and returns
 157:d:\development\rp6\avr\include\stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 158:d:\development\rp6\avr\include\stdlib.h ****      contains two int members named \c quot and \c rem.
 159:d:\development\rp6\avr\include\stdlib.h **** */
 160:d:\development\rp6\avr\include\stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 161:d:\development\rp6\avr\include\stdlib.h **** /**
 162:d:\development\rp6\avr\include\stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 163:d:\development\rp6\avr\include\stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 164:d:\development\rp6\avr\include\stdlib.h ****      contains two long integer members named \c quot and \c rem.
 165:d:\development\rp6\avr\include\stdlib.h **** */
 166:d:\development\rp6\avr\include\stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 167:d:\development\rp6\avr\include\stdlib.h **** 
 168:d:\development\rp6\avr\include\stdlib.h **** /**
 169:d:\development\rp6\avr\include\stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 170:d:\development\rp6\avr\include\stdlib.h ****      quicksort.
 171:d:\development\rp6\avr\include\stdlib.h **** 
 172:d:\development\rp6\avr\include\stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 173:d:\development\rp6\avr\include\stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 174:d:\development\rp6\avr\include\stdlib.h ****      each object is specified by \c size.  The contents of the array
 175:d:\development\rp6\avr\include\stdlib.h ****      base are sorted in ascending order according to a comparison
 176:d:\development\rp6\avr\include\stdlib.h ****      function pointed to by \c compar, which requires two arguments
 177:d:\development\rp6\avr\include\stdlib.h ****      pointing to the objects being compared.
 178:d:\development\rp6\avr\include\stdlib.h **** 
 179:d:\development\rp6\avr\include\stdlib.h ****      The comparison function must return an integer less than, equal
 180:d:\development\rp6\avr\include\stdlib.h ****      to, or greater than zero if the first argument is considered to
 181:d:\development\rp6\avr\include\stdlib.h ****      be respectively less than, equal to, or greater than the second.
 182:d:\development\rp6\avr\include\stdlib.h **** */
 183:d:\development\rp6\avr\include\stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 184:d:\development\rp6\avr\include\stdlib.h **** 		  __compar_fn_t __compar);
 185:d:\development\rp6\avr\include\stdlib.h **** 
 186:d:\development\rp6\avr\include\stdlib.h **** /**
 187:d:\development\rp6\avr\include\stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 188:d:\development\rp6\avr\include\stdlib.h ****     value.  The conversion is done according to the given base, which
 189:d:\development\rp6\avr\include\stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 190:d:\development\rp6\avr\include\stdlib.h **** 
 191:d:\development\rp6\avr\include\stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 192:d:\development\rp6\avr\include\stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 193:d:\development\rp6\avr\include\stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 194:d:\development\rp6\avr\include\stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 195:d:\development\rp6\avr\include\stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 196:d:\development\rp6\avr\include\stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 197:d:\development\rp6\avr\include\stdlib.h **** 
 198:d:\development\rp6\avr\include\stdlib.h ****     The remainder of the string is converted to a long value in the
 199:d:\development\rp6\avr\include\stdlib.h ****     obvious manner, stopping at the first character which is not a
 200:d:\development\rp6\avr\include\stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 201:d:\development\rp6\avr\include\stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 202:d:\development\rp6\avr\include\stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 203:d:\development\rp6\avr\include\stdlib.h **** 
 204:d:\development\rp6\avr\include\stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 205:d:\development\rp6\avr\include\stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 206:d:\development\rp6\avr\include\stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 207:d:\development\rp6\avr\include\stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 208:d:\development\rp6\avr\include\stdlib.h ****     on return, the entire string was valid.)
 209:d:\development\rp6\avr\include\stdlib.h **** 
 210:d:\development\rp6\avr\include\stdlib.h ****     The strtol() function returns the result of the conversion, unless
 211:d:\development\rp6\avr\include\stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 212:d:\development\rp6\avr\include\stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 213:d:\development\rp6\avr\include\stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 214:d:\development\rp6\avr\include\stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 215:d:\development\rp6\avr\include\stdlib.h **** */
 216:d:\development\rp6\avr\include\stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 217:d:\development\rp6\avr\include\stdlib.h **** 
 218:d:\development\rp6\avr\include\stdlib.h **** /**
 219:d:\development\rp6\avr\include\stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 220:d:\development\rp6\avr\include\stdlib.h ****     unsigned long value.  The conversion is done according to the
 221:d:\development\rp6\avr\include\stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 222:d:\development\rp6\avr\include\stdlib.h ****     special value 0.
 223:d:\development\rp6\avr\include\stdlib.h **** 
 224:d:\development\rp6\avr\include\stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 225:d:\development\rp6\avr\include\stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 226:d:\development\rp6\avr\include\stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 227:d:\development\rp6\avr\include\stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 228:d:\development\rp6\avr\include\stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 229:d:\development\rp6\avr\include\stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 230:d:\development\rp6\avr\include\stdlib.h **** 
 231:d:\development\rp6\avr\include\stdlib.h ****     The remainder of the string is converted to an unsigned long value
 232:d:\development\rp6\avr\include\stdlib.h ****     in the obvious manner, stopping at the first character which is
 233:d:\development\rp6\avr\include\stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 234:d:\development\rp6\avr\include\stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 235:d:\development\rp6\avr\include\stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 236:d:\development\rp6\avr\include\stdlib.h **** 
 237:d:\development\rp6\avr\include\stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 238:d:\development\rp6\avr\include\stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 239:d:\development\rp6\avr\include\stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 240:d:\development\rp6\avr\include\stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 241:d:\development\rp6\avr\include\stdlib.h ****     on return, the entire string was valid.)
 242:d:\development\rp6\avr\include\stdlib.h **** 
 243:d:\development\rp6\avr\include\stdlib.h ****     The strtoul() function return either the result of the conversion
 244:d:\development\rp6\avr\include\stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 245:d:\development\rp6\avr\include\stdlib.h ****     of the conversion, unless the original (non-negated) value would
 246:d:\development\rp6\avr\include\stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 247:d:\development\rp6\avr\include\stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 248:d:\development\rp6\avr\include\stdlib.h ****     be performed, 0 is returned.
 249:d:\development\rp6\avr\include\stdlib.h **** */
 250:d:\development\rp6\avr\include\stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 251:d:\development\rp6\avr\include\stdlib.h **** 
 252:d:\development\rp6\avr\include\stdlib.h **** /**
 253:d:\development\rp6\avr\include\stdlib.h ****     The atol() function converts the initial portion of the string
 254:d:\development\rp6\avr\include\stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 255:d:\development\rp6\avr\include\stdlib.h **** 
 256:d:\development\rp6\avr\include\stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 257:d:\development\rp6\avr\include\stdlib.h **** 
 258:d:\development\rp6\avr\include\stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 259:d:\development\rp6\avr\include\stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 260:d:\development\rp6\avr\include\stdlib.h ****     stack) and works more quickly.
 261:d:\development\rp6\avr\include\stdlib.h **** */
 262:d:\development\rp6\avr\include\stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 263:d:\development\rp6\avr\include\stdlib.h **** 
 264:d:\development\rp6\avr\include\stdlib.h **** /**
 265:d:\development\rp6\avr\include\stdlib.h ****     The atoi() function converts the initial portion of the string
 266:d:\development\rp6\avr\include\stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 267:d:\development\rp6\avr\include\stdlib.h **** 
 268:d:\development\rp6\avr\include\stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 269:d:\development\rp6\avr\include\stdlib.h **** 
 270:d:\development\rp6\avr\include\stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 271:d:\development\rp6\avr\include\stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 272:d:\development\rp6\avr\include\stdlib.h ****     stack) and works more quickly.
 273:d:\development\rp6\avr\include\stdlib.h **** */
 274:d:\development\rp6\avr\include\stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 275:d:\development\rp6\avr\include\stdlib.h **** 
 276:d:\development\rp6\avr\include\stdlib.h **** /**
 277:d:\development\rp6\avr\include\stdlib.h ****    The exit() function terminates the application.  Since there is no
 278:d:\development\rp6\avr\include\stdlib.h ****    environment to return to, \c status is ignored, and code execution
 279:d:\development\rp6\avr\include\stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 280:d:\development\rp6\avr\include\stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 281:d:\development\rp6\avr\include\stdlib.h ****    are globally disabled.
 282:d:\development\rp6\avr\include\stdlib.h **** 
 283:d:\development\rp6\avr\include\stdlib.h ****    In a C++ context, global destructors will be called before halting
 284:d:\development\rp6\avr\include\stdlib.h ****    execution.
 285:d:\development\rp6\avr\include\stdlib.h **** */
 286:d:\development\rp6\avr\include\stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 287:d:\development\rp6\avr\include\stdlib.h **** 
 288:d:\development\rp6\avr\include\stdlib.h **** /**
 289:d:\development\rp6\avr\include\stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 290:d:\development\rp6\avr\include\stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 291:d:\development\rp6\avr\include\stdlib.h **** 
 292:d:\development\rp6\avr\include\stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 293:d:\development\rp6\avr\include\stdlib.h ****    zero bytes.
 294:d:\development\rp6\avr\include\stdlib.h **** 
 295:d:\development\rp6\avr\include\stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 296:d:\development\rp6\avr\include\stdlib.h ****    details.
 297:d:\development\rp6\avr\include\stdlib.h **** */
 298:d:\development\rp6\avr\include\stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 299:d:\development\rp6\avr\include\stdlib.h **** 
 300:d:\development\rp6\avr\include\stdlib.h **** /**
 301:d:\development\rp6\avr\include\stdlib.h ****    The free() function causes the allocated memory referenced by \c
 302:d:\development\rp6\avr\include\stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 303:d:\development\rp6\avr\include\stdlib.h ****    NULL, no action occurs.
 304:d:\development\rp6\avr\include\stdlib.h **** */
 305:d:\development\rp6\avr\include\stdlib.h **** extern void free(void *__ptr);
 306:d:\development\rp6\avr\include\stdlib.h **** 
 307:d:\development\rp6\avr\include\stdlib.h **** /**
 308:d:\development\rp6\avr\include\stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 309:d:\development\rp6\avr\include\stdlib.h **** */
 310:d:\development\rp6\avr\include\stdlib.h **** extern size_t __malloc_margin;
 311:d:\development\rp6\avr\include\stdlib.h **** 
 312:d:\development\rp6\avr\include\stdlib.h **** /**
 313:d:\development\rp6\avr\include\stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 314:d:\development\rp6\avr\include\stdlib.h **** */
 315:d:\development\rp6\avr\include\stdlib.h **** extern char *__malloc_heap_start;
 316:d:\development\rp6\avr\include\stdlib.h **** 
 317:d:\development\rp6\avr\include\stdlib.h **** /**
 318:d:\development\rp6\avr\include\stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 319:d:\development\rp6\avr\include\stdlib.h **** */
 320:d:\development\rp6\avr\include\stdlib.h **** extern char *__malloc_heap_end;
 321:d:\development\rp6\avr\include\stdlib.h **** 
 322:d:\development\rp6\avr\include\stdlib.h **** /**
 323:d:\development\rp6\avr\include\stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 324:d:\development\rp6\avr\include\stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 325:d:\development\rp6\avr\include\stdlib.h ****    allocated memory will be cleared to zero.
 326:d:\development\rp6\avr\include\stdlib.h **** */
 327:d:\development\rp6\avr\include\stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 328:d:\development\rp6\avr\include\stdlib.h **** 
 329:d:\development\rp6\avr\include\stdlib.h **** /**
 330:d:\development\rp6\avr\include\stdlib.h ****    The realloc() function tries to change the size of the region
 331:d:\development\rp6\avr\include\stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 332:d:\development\rp6\avr\include\stdlib.h ****    pointer to the new region.  The returned pointer might be the
 333:d:\development\rp6\avr\include\stdlib.h ****    same as the old pointer, or a pointer to a completely different
 334:d:\development\rp6\avr\include\stdlib.h ****    region.
 335:d:\development\rp6\avr\include\stdlib.h **** 
 336:d:\development\rp6\avr\include\stdlib.h ****    The contents of the returned region up to either the old or the new
 337:d:\development\rp6\avr\include\stdlib.h ****    size value (whatever is less) will be identical to the contents of
 338:d:\development\rp6\avr\include\stdlib.h ****    the old region, even in case a new region had to be allocated.
 339:d:\development\rp6\avr\include\stdlib.h **** 
 340:d:\development\rp6\avr\include\stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 341:d:\development\rp6\avr\include\stdlib.h ****    will behave identical to malloc().
 342:d:\development\rp6\avr\include\stdlib.h **** 
 343:d:\development\rp6\avr\include\stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 344:d:\development\rp6\avr\include\stdlib.h ****    the region at \c ptr will not be changed.
 345:d:\development\rp6\avr\include\stdlib.h **** */
 346:d:\development\rp6\avr\include\stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 347:d:\development\rp6\avr\include\stdlib.h **** 
 348:d:\development\rp6\avr\include\stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 349:d:\development\rp6\avr\include\stdlib.h **** 
 350:d:\development\rp6\avr\include\stdlib.h **** extern double atof(const char *__nptr);
 351:d:\development\rp6\avr\include\stdlib.h **** 
 352:d:\development\rp6\avr\include\stdlib.h **** /** Highest number that can be generated by rand(). */
 353:d:\development\rp6\avr\include\stdlib.h **** #define	RAND_MAX 0x7FFF
 354:d:\development\rp6\avr\include\stdlib.h **** 
 355:d:\development\rp6\avr\include\stdlib.h **** /**
 356:d:\development\rp6\avr\include\stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 357:d:\development\rp6\avr\include\stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 358:d:\development\rp6\avr\include\stdlib.h **** 
 359:d:\development\rp6\avr\include\stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 360:d:\development\rp6\avr\include\stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 361:d:\development\rp6\avr\include\stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 362:d:\development\rp6\avr\include\stdlib.h **** 
 363:d:\development\rp6\avr\include\stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 364:d:\development\rp6\avr\include\stdlib.h ****      a value of 1.
 365:d:\development\rp6\avr\include\stdlib.h **** 
 366:d:\development\rp6\avr\include\stdlib.h ****      In compliance with the C standard, these functions operate on
 367:d:\development\rp6\avr\include\stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 368:d:\development\rp6\avr\include\stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 369:d:\development\rp6\avr\include\stdlib.h ****      \c random() for an alternate set of functions that retains full
 370:d:\development\rp6\avr\include\stdlib.h ****      32-bit precision.
 371:d:\development\rp6\avr\include\stdlib.h **** */
 372:d:\development\rp6\avr\include\stdlib.h **** extern int rand(void);
 373:d:\development\rp6\avr\include\stdlib.h **** /**
 374:d:\development\rp6\avr\include\stdlib.h ****    Pseudo-random number generator seeding; see rand().
 375:d:\development\rp6\avr\include\stdlib.h **** */
 376:d:\development\rp6\avr\include\stdlib.h **** extern void srand(unsigned int __seed);
 377:d:\development\rp6\avr\include\stdlib.h **** 
 378:d:\development\rp6\avr\include\stdlib.h **** /**
 379:d:\development\rp6\avr\include\stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 380:d:\development\rp6\avr\include\stdlib.h ****    variable located at \c ctx instead of a static library variable
 381:d:\development\rp6\avr\include\stdlib.h ****    so the function becomes re-entrant.
 382:d:\development\rp6\avr\include\stdlib.h **** */
 383:d:\development\rp6\avr\include\stdlib.h **** extern int rand_r(unsigned long *__ctx);
 384:d:\development\rp6\avr\include\stdlib.h **** /*@}*/
 385:d:\development\rp6\avr\include\stdlib.h **** 
 386:d:\development\rp6\avr\include\stdlib.h **** /*@{*/
 387:d:\development\rp6\avr\include\stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 388:d:\development\rp6\avr\include\stdlib.h ****  \ingroup avr_stdlib
 389:d:\development\rp6\avr\include\stdlib.h **** */
 390:d:\development\rp6\avr\include\stdlib.h **** /**
 391:d:\development\rp6\avr\include\stdlib.h ****    \brief Convert an integer to a string.
 392:d:\development\rp6\avr\include\stdlib.h **** 
 393:d:\development\rp6\avr\include\stdlib.h ****    The function itoa() converts the integer value from \c val into an
 394:d:\development\rp6\avr\include\stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 395:d:\development\rp6\avr\include\stdlib.h ****    is responsible for providing sufficient storage in \c s.
 396:d:\development\rp6\avr\include\stdlib.h **** 
 397:d:\development\rp6\avr\include\stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 398:d:\development\rp6\avr\include\stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 399:d:\development\rp6\avr\include\stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 400:d:\development\rp6\avr\include\stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 401:d:\development\rp6\avr\include\stdlib.h ****    radix will require a smaller minimal buffer size.
 402:d:\development\rp6\avr\include\stdlib.h **** 
 403:d:\development\rp6\avr\include\stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 404:d:\development\rp6\avr\include\stdlib.h **** 
 405:d:\development\rp6\avr\include\stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 406:d:\development\rp6\avr\include\stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 407:d:\development\rp6\avr\include\stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 408:d:\development\rp6\avr\include\stdlib.h ****    \c 'a'.
 409:d:\development\rp6\avr\include\stdlib.h ****     
 410:d:\development\rp6\avr\include\stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 411:d:\development\rp6\avr\include\stdlib.h **** 
 412:d:\development\rp6\avr\include\stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 413:d:\development\rp6\avr\include\stdlib.h **** */
 414:d:\development\rp6\avr\include\stdlib.h **** #ifdef  __DOXYGEN__
 415:d:\development\rp6\avr\include\stdlib.h **** extern char *itoa(int val, char *s, int radix);
 416:d:\development\rp6\avr\include\stdlib.h **** #else
 417:d:\development\rp6\avr\include\stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 418:d:\development\rp6\avr\include\stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 419:d:\development\rp6\avr\include\stdlib.h **** {
 420:d:\development\rp6\avr\include\stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 421:d:\development\rp6\avr\include\stdlib.h **** 	extern char *__itoa (int, char *, int);
 422:d:\development\rp6\avr\include\stdlib.h **** 	return __itoa (__val, __s, __radix);
 2096               		.loc 2 422 0
 2097 06e2 60E0      		ldi r22,lo8(lcd_tmp_buffer)
 2098 06e4 70E0      		ldi r23,hi8(lcd_tmp_buffer)
 2099               	.LVL164:
 2100 06e6 0E94 0000 		call __itoa
 2101               	.LVL165:
 2102               	.LBE21:
 2103               	.LBE20:
 491:RP6Lib/RP6control/RP6ControlLib.c **** }
 2104               		.loc 1 491 0
 2105 06ea 80E0      		ldi r24,lo8(lcd_tmp_buffer)
 2106 06ec 90E0      		ldi r25,hi8(lcd_tmp_buffer)
 2107 06ee 0C94 0000 		jmp writeStringLCD
 2108               	.LVL166:
 2109               		.cfi_endproc
 2110               	.LFE45:
 2112               	.global	writeStringLengthLCD
 2114               	writeStringLengthLCD:
 2115               	.LFB44:
 468:RP6Lib/RP6control/RP6ControlLib.c **** 	for(string = &string[offset]; *string && length; length--)
 2116               		.loc 1 468 0
 2117               		.cfi_startproc
 2118               	.LVL167:
 2119 06f2 0F93      		push r16
 2120               	.LCFI87:
 2121               		.cfi_def_cfa_offset 3
 2122               		.cfi_offset 16, -2
 2123 06f4 1F93      		push r17
 2124               	.LCFI88:
 2125               		.cfi_def_cfa_offset 4
 2126               		.cfi_offset 17, -3
 2127 06f6 CF93      		push r28
 2128               	.LCFI89:
 2129               		.cfi_def_cfa_offset 5
 2130               		.cfi_offset 28, -4
 2131 06f8 DF93      		push r29
 2132               	.LCFI90:
 2133               		.cfi_def_cfa_offset 6
 2134               		.cfi_offset 29, -5
 2135 06fa 1F92      		push __zero_reg__
 2136               	.LCFI91:
 2137               		.cfi_def_cfa_offset 7
 2138 06fc CDB7      		in r28,__SP_L__
 2139 06fe DEB7      		in r29,__SP_H__
 2140               	.LCFI92:
 2141               		.cfi_def_cfa_register 28
 2142               	/* prologue: function */
 2143               	/* frame size = 1 */
 2144               	/* stack size = 5 */
 2145               	.L__stack_usage = 5
 2146               	.LVL168:
 469:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(*string++);
 2147               		.loc 1 469 0
 2148 0700 8C01      		movw r16,r24
 2149 0702 040F      		add r16,r20
 2150 0704 111D      		adc r17,__zero_reg__
 2151               	.LVL169:
 2152               	.L136:
 469:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(*string++);
 2153               		.loc 1 469 0 is_stmt 0 discriminator 1
 2154 0706 F801      		movw r30,r16
 2155 0708 8191      		ld r24,Z+
 2156 070a 8F01      		movw r16,r30
 2157               	.LVL170:
 2158 070c 8823      		tst r24
 2159 070e 01F0      		breq .L135
 469:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(*string++);
 2160               		.loc 1 469 0 discriminator 2
 2161 0710 6623      		tst r22
 2162 0712 01F0      		breq .L135
 2163               	.LVL171:
 470:RP6Lib/RP6control/RP6ControlLib.c **** }
 2164               		.loc 1 470 0 is_stmt 1 discriminator 1
 2165 0714 6983      		std Y+1,r22
 2166 0716 0E94 0000 		call writeCharLCD
 2167               	.LVL172:
 469:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(*string++);
 2168               		.loc 1 469 0 discriminator 1
 2169 071a 6981      		ldd r22,Y+1
 2170 071c 6150      		subi r22,lo8(-(-1))
 2171               	.LVL173:
 2172 071e 00C0      		rjmp .L136
 2173               	.LVL174:
 2174               	.L135:
 2175               	/* epilogue start */
 471:RP6Lib/RP6control/RP6ControlLib.c **** 
 2176               		.loc 1 471 0
 2177 0720 0F90      		pop __tmp_reg__
 2178 0722 DF91      		pop r29
 2179 0724 CF91      		pop r28
 2180 0726 1F91      		pop r17
 2181 0728 0F91      		pop r16
 2182               	.LVL175:
 2183 072a 0895      		ret
 2184               		.cfi_endproc
 2185               	.LFE44:
 2187               	.global	writeIntegerLengthLCD
 2189               	writeIntegerLengthLCD:
 2190               	.LFB46:
 514:RP6Lib/RP6control/RP6ControlLib.c **** 	char buffer[17];
 2191               		.loc 1 514 0
 2192               		.cfi_startproc
 2193               	.LVL176:
 2194 072c EF92      		push r14
 2195               	.LCFI93:
 2196               		.cfi_def_cfa_offset 3
 2197               		.cfi_offset 14, -2
 2198 072e FF92      		push r15
 2199               	.LCFI94:
 2200               		.cfi_def_cfa_offset 4
 2201               		.cfi_offset 15, -3
 2202 0730 0F93      		push r16
 2203               	.LCFI95:
 2204               		.cfi_def_cfa_offset 5
 2205               		.cfi_offset 16, -4
 2206 0732 1F93      		push r17
 2207               	.LCFI96:
 2208               		.cfi_def_cfa_offset 6
 2209               		.cfi_offset 17, -5
 2210 0734 CF93      		push r28
 2211               	.LCFI97:
 2212               		.cfi_def_cfa_offset 7
 2213               		.cfi_offset 28, -6
 2214 0736 DF93      		push r29
 2215               	.LCFI98:
 2216               		.cfi_def_cfa_offset 8
 2217               		.cfi_offset 29, -7
 2218 0738 CDB7      		in r28,__SP_L__
 2219 073a DEB7      		in r29,__SP_H__
 2220               	.LCFI99:
 2221               		.cfi_def_cfa_register 28
 2222 073c 6197      		sbiw r28,17
 2223               	.LCFI100:
 2224               		.cfi_def_cfa_offset 25
 2225 073e 0FB6      		in __tmp_reg__,__SREG__
 2226 0740 F894      		cli
 2227 0742 DEBF      		out __SP_H__,r29
 2228 0744 0FBE      		out __SREG__,__tmp_reg__
 2229 0746 CDBF      		out __SP_L__,r28
 2230               	/* prologue: function */
 2231               	/* frame size = 17 */
 2232               	/* stack size = 23 */
 2233               	.L__stack_usage = 23
 2234 0748 E42E      		mov r14,r20
 2235               	.LVL177:
 516:RP6Lib/RP6control/RP6ControlLib.c **** 	int8_t cnt = length - strlen(buffer);
 2236               		.loc 1 516 0
 2237 074a 462F      		mov r20,r22
 2238               	.LVL178:
 2239 074c 50E0      		ldi r21,0
 2240               	.LBB22:
 2241               	.LBB23:
 2242               		.loc 2 422 0
 2243 074e 8E01      		movw r16,r28
 2244 0750 0F5F      		subi r16,-1
 2245 0752 1F4F      		sbci r17,-1
 2246 0754 B801      		movw r22,r16
 2247               	.LVL179:
 2248 0756 0E94 0000 		call __itoa
 2249               	.LVL180:
 2250               	.LBE23:
 2251               	.LBE22:
 517:RP6Lib/RP6control/RP6ControlLib.c **** 	if(cnt > 0) {
 2252               		.loc 1 517 0
 2253 075a F801      		movw r30,r16
 2254               		0:
 2255 075c 0190      		ld __tmp_reg__,Z+
 2256 075e 0020      		tst __tmp_reg__
 2257 0760 01F4      		brne 0b
 2258 0762 3197      		sbiw r30,1
 2259 0764 E01B      		sub r30,r16
 2260 0766 F10B      		sbc r31,r17
 2261 0768 FE2C      		mov r15,r14
 2262 076a FE1A      		sub r15,r30
 2263               	.LVL181:
 518:RP6Lib/RP6control/RP6ControlLib.c **** 		for(; cnt > 0; cnt--, writeCharLCD('0'));
 2264               		.loc 1 518 0
 2265 076c 1F14      		cp __zero_reg__,r15
 2266 076e 04F4      		brge .L143
 2267               	.L145:
 2268 0770 FA94      		dec r15
 2269               	.LVL182:
 519:RP6Lib/RP6control/RP6ControlLib.c **** 		writeStringLCD(&buffer[0]);
 2270               		.loc 1 519 0 discriminator 2
 2271 0772 80E3      		ldi r24,lo8(48)
 2272 0774 0E94 0000 		call writeCharLCD
 2273               	.LVL183:
 2274 0778 F110      		cpse r15,__zero_reg__
 2275 077a 00C0      		rjmp .L145
 520:RP6Lib/RP6control/RP6ControlLib.c **** 	}
 2276               		.loc 1 520 0
 2277 077c C801      		movw r24,r16
 2278 077e 0E94 0000 		call writeStringLCD
 2279               	.LVL184:
 2280 0782 00C0      		rjmp .L142
 2281               	.L143:
 523:RP6Lib/RP6control/RP6ControlLib.c **** }
 2282               		.loc 1 523 0
 2283 0784 4F2D      		mov r20,r15
 2284 0786 4195      		neg r20
 2285 0788 6E2D      		mov r22,r14
 2286 078a C801      		movw r24,r16
 2287 078c 0E94 0000 		call writeStringLengthLCD
 2288               	.LVL185:
 2289               	.L142:
 2290               	/* epilogue start */
 524:RP6Lib/RP6control/RP6ControlLib.c **** 
 2291               		.loc 1 524 0
 2292 0790 6196      		adiw r28,17
 2293 0792 0FB6      		in __tmp_reg__,__SREG__
 2294 0794 F894      		cli
 2295 0796 DEBF      		out __SP_H__,r29
 2296 0798 0FBE      		out __SREG__,__tmp_reg__
 2297 079a CDBF      		out __SP_L__,r28
 2298 079c DF91      		pop r29
 2299 079e CF91      		pop r28
 2300 07a0 1F91      		pop r17
 2301 07a2 0F91      		pop r16
 2302 07a4 FF90      		pop r15
 2303               	.LVL186:
 2304 07a6 EF90      		pop r14
 2305               	.LVL187:
 2306 07a8 0895      		ret
 2307               		.cfi_endproc
 2308               	.LFE46:
 2310               	.global	clearPosLCD
 2312               	clearPosLCD:
 2313               	.LFB49:
 553:RP6Lib/RP6control/RP6ControlLib.c **** 	setCursorPosLCD(line,pos);
 2314               		.loc 1 553 0
 2315               		.cfi_startproc
 2316               	.LVL188:
 2317 07aa CF93      		push r28
 2318               	.LCFI101:
 2319               		.cfi_def_cfa_offset 3
 2320               		.cfi_offset 28, -2
 2321               	/* prologue: function */
 2322               	/* frame size = 0 */
 2323               	/* stack size = 1 */
 2324               	.L__stack_usage = 1
 2325 07ac C42F      		mov r28,r20
 554:RP6Lib/RP6control/RP6ControlLib.c **** 	while(length--)
 2326               		.loc 1 554 0
 2327 07ae 0E94 0000 		call setCursorPosLCD
 2328               	.LVL189:
 2329               	.L148:
 555:RP6Lib/RP6control/RP6ControlLib.c **** 		writeCharLCD(' ');
 2330               		.loc 1 555 0 discriminator 1
 2331 07b2 CC23      		tst r28
 2332 07b4 01F0      		breq .L150
 556:RP6Lib/RP6control/RP6ControlLib.c **** }
 2333               		.loc 1 556 0
 2334 07b6 80E2      		ldi r24,lo8(32)
 2335 07b8 0E94 0000 		call writeCharLCD
 2336               	.LVL190:
 2337 07bc C150      		subi r28,lo8(-(-1))
 2338               	.LVL191:
 2339 07be 00C0      		rjmp .L148
 2340               	.LVL192:
 2341               	.L150:
 2342               	/* epilogue start */
 557:RP6Lib/RP6control/RP6ControlLib.c **** 
 2343               		.loc 1 557 0
 2344 07c0 CF91      		pop r28
 2345               	.LVL193:
 2346 07c2 0895      		ret
 2347               		.cfi_endproc
 2348               	.LFE49:
 2350               	.global	initRP6Control
 2352               	initRP6Control:
 2353               	.LFB61:
 842:RP6Lib/RP6control/RP6ControlLib.c **** 
 843:RP6Lib/RP6control/RP6ControlLib.c **** 
 844:RP6Lib/RP6control/RP6ControlLib.c **** /*****************************************************************************/
 845:RP6Lib/RP6control/RP6ControlLib.c **** // Initialisation:
 846:RP6Lib/RP6control/RP6ControlLib.c **** 
 847:RP6Lib/RP6control/RP6ControlLib.c **** /**
 848:RP6Lib/RP6control/RP6ControlLib.c ****  * Initialize the Controller - ALWAYS CALL THIS FIRST!
 849:RP6Lib/RP6control/RP6ControlLib.c ****  * The Processor will not work correctly otherwise.
 850:RP6Lib/RP6control/RP6ControlLib.c ****  * (If you don't implement your own init routine...)
 851:RP6Lib/RP6control/RP6ControlLib.c ****  *
 852:RP6Lib/RP6control/RP6ControlLib.c ****  * Example:
 853:RP6Lib/RP6control/RP6ControlLib.c ****  *
 854:RP6Lib/RP6control/RP6ControlLib.c ****  *			int main(void)
 855:RP6Lib/RP6control/RP6ControlLib.c ****  *			{
 856:RP6Lib/RP6control/RP6ControlLib.c ****  *				initRP6Control(); // CALL THIS FIRST!
 857:RP6Lib/RP6control/RP6ControlLib.c ****  *
 858:RP6Lib/RP6control/RP6ControlLib.c ****  *				// ... your application code
 859:RP6Lib/RP6control/RP6ControlLib.c ****  *
 860:RP6Lib/RP6control/RP6ControlLib.c ****  *				while(true);
 861:RP6Lib/RP6control/RP6ControlLib.c ****  *				return 0;
 862:RP6Lib/RP6control/RP6ControlLib.c ****  *			}
 863:RP6Lib/RP6control/RP6ControlLib.c ****  *
 864:RP6Lib/RP6control/RP6ControlLib.c ****  */
 865:RP6Lib/RP6control/RP6ControlLib.c **** void initRP6Control(void)
 866:RP6Lib/RP6control/RP6ControlLib.c **** {
 2354               		.loc 1 866 0
 2355               		.cfi_startproc
 2356               	/* prologue: function */
 2357               	/* frame size = 0 */
 2358               	/* stack size = 0 */
 2359               	.L__stack_usage = 0
 867:RP6Lib/RP6control/RP6ControlLib.c **** 	portInit();		// Setup port directions and initial values.
 2360               		.loc 1 867 0
 2361 07c4 1BBA      		out 0x1b,__zero_reg__
 2362 07c6 87E0      		ldi r24,lo8(7)
 2363 07c8 88BB      		out 0x18,r24
 2364 07ca 8CEF      		ldi r24,lo8(-4)
 2365 07cc 85BB      		out 0x15,r24
 2366 07ce 81E6      		ldi r24,lo8(97)
 2367 07d0 82BB      		out 0x12,r24
 2368 07d2 1ABA      		out 0x1a,__zero_reg__
 2369 07d4 8BEB      		ldi r24,lo8(-69)
 2370 07d6 87BB      		out 0x17,r24
 2371 07d8 14BA      		out 0x14,__zero_reg__
 2372 07da 82E9      		ldi r24,lo8(-110)
 2373 07dc 81BB      		out 0x11,r24
 868:RP6Lib/RP6control/RP6ControlLib.c **** 					// This is the most important step!
 869:RP6Lib/RP6control/RP6ControlLib.c **** 
 870:RP6Lib/RP6control/RP6ControlLib.c **** 	cli();			// Disable global interrupts.
 2374               		.loc 1 870 0
 2375               	/* #APP */
 2376               	 ;  870 "RP6Lib/RP6control/RP6ControlLib.c" 1
 2377 07de F894      		cli
 2378               	 ;  0 "" 2
 871:RP6Lib/RP6control/RP6ControlLib.c **** 
 872:RP6Lib/RP6control/RP6ControlLib.c **** 	// UART:
 873:RP6Lib/RP6control/RP6ControlLib.c **** 	UBRRH = UBRR_BAUD_LOW >> 8;	// Setup UART: Baud is Low Speed
 2379               		.loc 1 873 0
 2380               	/* #NOAPP */
 2381 07e0 10BC      		out 0x20,__zero_reg__
 874:RP6Lib/RP6control/RP6ControlLib.c **** 	UBRRL = (uint8_t) UBRR_BAUD_LOW;
 2382               		.loc 1 874 0
 2383 07e2 89E1      		ldi r24,lo8(25)
 2384 07e4 89B9      		out 0x9,r24
 875:RP6Lib/RP6control/RP6ControlLib.c **** 	UCSRA = 0x00;
 2385               		.loc 1 875 0
 2386 07e6 1BB8      		out 0xb,__zero_reg__
 876:RP6Lib/RP6control/RP6ControlLib.c ****     UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
 2387               		.loc 1 876 0
 2388 07e8 86E8      		ldi r24,lo8(-122)
 2389 07ea 80BD      		out 0x20,r24
 877:RP6Lib/RP6control/RP6ControlLib.c ****     UCSRB = (1 << TXEN) | (1 << RXEN) | (1 << RXCIE);
 2390               		.loc 1 877 0
 2391 07ec 88E9      		ldi r24,lo8(-104)
 2392 07ee 8AB9      		out 0xa,r24
 878:RP6Lib/RP6control/RP6ControlLib.c **** 	
 879:RP6Lib/RP6control/RP6ControlLib.c **** 	// Initialize ADC:
 880:RP6Lib/RP6control/RP6ControlLib.c **** 	ADMUX = 0; //external reference 
 2393               		.loc 1 880 0
 2394 07f0 17B8      		out 0x7,__zero_reg__
 881:RP6Lib/RP6control/RP6ControlLib.c **** 	ADCSRA = (0<<ADIE) | (0<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADIF);
 2395               		.loc 1 881 0
 2396 07f2 86E1      		ldi r24,lo8(22)
 2397 07f4 86B9      		out 0x6,r24
 882:RP6Lib/RP6control/RP6ControlLib.c **** 	SFIOR = 0;
 2398               		.loc 1 882 0
 2399 07f6 10BE      		out 0x30,__zero_reg__
 883:RP6Lib/RP6control/RP6ControlLib.c **** 
 884:RP6Lib/RP6control/RP6ControlLib.c **** 	// Initialize External interrupts - all disabled:
 885:RP6Lib/RP6control/RP6ControlLib.c **** 	MCUCR = (1 << ISC11) | (1 << ISC10) | (1 << ISC01) | (1 << ISC00);
 2400               		.loc 1 885 0
 2401 07f8 8FE0      		ldi r24,lo8(15)
 2402 07fa 85BF      		out 0x35,r24
 886:RP6Lib/RP6control/RP6ControlLib.c **** 	GICR = (0 << INT2) | (0 << INT1) | (0 << INT0);
 2403               		.loc 1 886 0
 2404 07fc 1BBE      		out 0x3b,__zero_reg__
 887:RP6Lib/RP6control/RP6ControlLib.c **** 	MCUCSR = (0 << ISC2);
 2405               		.loc 1 887 0
 2406 07fe 14BE      		out 0x34,__zero_reg__
 888:RP6Lib/RP6control/RP6ControlLib.c **** 	
 889:RP6Lib/RP6control/RP6ControlLib.c **** 	
 890:RP6Lib/RP6control/RP6ControlLib.c **** 	// 10kHz Timer 0:
 891:RP6Lib/RP6control/RP6ControlLib.c **** 	TCCR0 =   (0 << WGM00) 
 2407               		.loc 1 891 0
 2408 0800 8AE0      		ldi r24,lo8(10)
 2409 0802 83BF      		out 0x33,r24
 892:RP6Lib/RP6control/RP6ControlLib.c **** 			| (1 << WGM01) 
 893:RP6Lib/RP6control/RP6ControlLib.c **** 			| (0 << COM00) 
 894:RP6Lib/RP6control/RP6ControlLib.c **** 			| (0 << COM01) 
 895:RP6Lib/RP6control/RP6ControlLib.c **** 			| (0 << CS02)  
 896:RP6Lib/RP6control/RP6ControlLib.c **** 			| (1 << CS01) 
 897:RP6Lib/RP6control/RP6ControlLib.c **** 			| (0 << CS00);
 898:RP6Lib/RP6control/RP6ControlLib.c **** 	OCR0  = 199;
 2410               		.loc 1 898 0
 2411 0804 87EC      		ldi r24,lo8(-57)
 2412 0806 8CBF      		out 0x3c,r24
 899:RP6Lib/RP6control/RP6ControlLib.c **** 	
 900:RP6Lib/RP6control/RP6ControlLib.c **** /*
 901:RP6Lib/RP6control/RP6ControlLib.c **** 	Timer 1 is free for your application!
 902:RP6Lib/RP6control/RP6ControlLib.c **** */
 903:RP6Lib/RP6control/RP6ControlLib.c **** 
 904:RP6Lib/RP6control/RP6ControlLib.c **** 	// Timer 2 - used for beeper:
 905:RP6Lib/RP6control/RP6ControlLib.c **** 	TCCR2 =  0; 
 2413               		.loc 1 905 0
 2414 0808 15BC      		out 0x25,__zero_reg__
 906:RP6Lib/RP6control/RP6ControlLib.c **** 	OCR2  = 0xFF; 
 2415               		.loc 1 906 0
 2416 080a 8FEF      		ldi r24,lo8(-1)
 2417 080c 83BD      		out 0x23,r24
 907:RP6Lib/RP6control/RP6ControlLib.c **** 
 908:RP6Lib/RP6control/RP6ControlLib.c **** 	// Enable timer interrupts:
 909:RP6Lib/RP6control/RP6ControlLib.c **** 	TIMSK =   (1 << OCIE0); 
 2418               		.loc 1 909 0
 2419 080e 82E0      		ldi r24,lo8(2)
 2420 0810 89BF      		out 0x39,r24
 910:RP6Lib/RP6control/RP6ControlLib.c **** 
 911:RP6Lib/RP6control/RP6ControlLib.c **** 	// SPI Master (SPI Mode 0, SCK Frequency is F_CPU/2, which means it is 8MHz 
 912:RP6Lib/RP6control/RP6ControlLib.c **** 	// on the RP6 CONTROL M32...):
 913:RP6Lib/RP6control/RP6ControlLib.c **** 	SPCR =    (0<<SPIE) 
 2421               		.loc 1 913 0
 2422 0812 80E5      		ldi r24,lo8(80)
 2423 0814 8DB9      		out 0xd,r24
 914:RP6Lib/RP6control/RP6ControlLib.c **** 			| (1<<SPE) 
 915:RP6Lib/RP6control/RP6ControlLib.c **** 			| (1<<MSTR) 
 916:RP6Lib/RP6control/RP6ControlLib.c **** 			| (0<<SPR0) 
 917:RP6Lib/RP6control/RP6ControlLib.c **** 			| (0<<SPR1) 
 918:RP6Lib/RP6control/RP6ControlLib.c **** 			| (0<<CPOL) 
 919:RP6Lib/RP6control/RP6ControlLib.c **** 			| (0<<CPHA);  
 920:RP6Lib/RP6control/RP6ControlLib.c **** 	SPSR = (1<<SPI2X);
 2424               		.loc 1 920 0
 2425 0816 81E0      		ldi r24,lo8(1)
 2426 0818 8EB9      		out 0xe,r24
 921:RP6Lib/RP6control/RP6ControlLib.c **** 	
 922:RP6Lib/RP6control/RP6ControlLib.c **** 	sei(); // Enable Global Interrupts
 2427               		.loc 1 922 0
 2428               	/* #APP */
 2429               	 ;  922 "RP6Lib/RP6control/RP6ControlLib.c" 1
 2430 081a 7894      		sei
 2431               	 ;  0 "" 2
 2432               	/* #NOAPP */
 2433 081c 0895      		ret
 2434               		.cfi_endproc
 2435               	.LFE61:
 2437               		.local	released_key.2400
 2438               		.comm	released_key.2400,1,1
 2439               		.local	pressed_key.2396
 2440               		.comm	pressed_key.2396,1,1
 2441               		.comm	sound_timer,2,1
 2442               		.comm	ms_timer,1,1
 2443               		.comm	delay_timer,1,1
 2444               		.comm	stopwatches,17,1
 2445               		.comm	controlStatus,1,1
 2446               		.comm	lcd_tmp_buffer,17,1
 2447               		.comm	externalPort,1,1
 2448               		.data
 2451               	INT2_eventHandler:
 2452 0000 0000      		.word	gs(INT2_event_DUMMY)
 2455               	INT1_eventHandler:
 2456 0002 0000      		.word	gs(INT1_event_DUMMY)
 2459               	INT0_eventHandler:
 2460 0004 0000      		.word	gs(INT0_event_DUMMY)
 2461               		.comm	timer,2,1
 2462               		.text
 2463               	.Letext0:
 2464               		.file 3 "d:\\development\\rp6\\avr\\include\\stdint.h"
 2465               		.file 4 "RP6Lib/RP6control/RP6ControlLib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 RP6ControlLib.c
D:\System\TEMP\ccYwJ6Mr.s:2      *ABS*:0000003e __SP_H__
D:\System\TEMP\ccYwJ6Mr.s:3      *ABS*:0000003d __SP_L__
D:\System\TEMP\ccYwJ6Mr.s:4      *ABS*:0000003f __SREG__
D:\System\TEMP\ccYwJ6Mr.s:5      *ABS*:00000000 __tmp_reg__
D:\System\TEMP\ccYwJ6Mr.s:6      *ABS*:00000001 __zero_reg__
D:\System\TEMP\ccYwJ6Mr.s:12     .text:00000000 INT0_event_DUMMY
D:\System\TEMP\ccYwJ6Mr.s:27     .text:00000002 INT1_event_DUMMY
D:\System\TEMP\ccYwJ6Mr.s:41     .text:00000004 INT2_event_DUMMY
D:\System\TEMP\ccYwJ6Mr.s:55     .text:00000006 INT0_setEventHandler
D:\System\TEMP\ccYwJ6Mr.s:2459   .data:00000004 INT0_eventHandler
D:\System\TEMP\ccYwJ6Mr.s:73     .text:00000010 __vector_1
D:\System\TEMP\ccYwJ6Mr.s:169    .text:0000005e INT1_setEventHandler
D:\System\TEMP\ccYwJ6Mr.s:2455   .data:00000002 INT1_eventHandler
D:\System\TEMP\ccYwJ6Mr.s:187    .text:00000068 __vector_2
D:\System\TEMP\ccYwJ6Mr.s:283    .text:000000b6 INT2_setEventHandler
D:\System\TEMP\ccYwJ6Mr.s:2451   .data:00000000 INT2_eventHandler
D:\System\TEMP\ccYwJ6Mr.s:301    .text:000000c0 __vector_3
D:\System\TEMP\ccYwJ6Mr.s:397    .text:0000010e readADC
D:\System\TEMP\ccYwJ6Mr.s:444    .text:0000012c writeSPI
D:\System\TEMP\ccYwJ6Mr.s:467    .text:00000134 readSPI
D:\System\TEMP\ccYwJ6Mr.s:488    .text:0000013e readWordSPI
D:\System\TEMP\ccYwJ6Mr.s:530    .text:0000015e writeWordSPI
D:\System\TEMP\ccYwJ6Mr.s:562    .text:00000170 writeBufferSPI
D:\System\TEMP\ccYwJ6Mr.s:600    .text:00000188 readBufferSPI
D:\System\TEMP\ccYwJ6Mr.s:641    .text:000001a4 SPI_EEPROM_readByte
D:\System\TEMP\ccYwJ6Mr.s:686    .text:000001c4 SPI_EEPROM_readBytes
D:\System\TEMP\ccYwJ6Mr.s:765    .text:00000206 SPI_EEPROM_enableWrite
D:\System\TEMP\ccYwJ6Mr.s:787    .text:00000212 SPI_EEPROM_disableWrite
D:\System\TEMP\ccYwJ6Mr.s:809    .text:0000021e SPI_EEPROM_getStatus
D:\System\TEMP\ccYwJ6Mr.s:835    .text:0000022e SPI_EEPROM_writeByte
D:\System\TEMP\ccYwJ6Mr.s:897    .text:00000262 SPI_EEPROM_writeBytes
D:\System\TEMP\ccYwJ6Mr.s:972    .text:000002a2 outputExt
                            *COM*:00000001 externalPort
D:\System\TEMP\ccYwJ6Mr.s:1006   .text:000002b4 setLEDs
D:\System\TEMP\ccYwJ6Mr.s:1030   .text:000002c6 getPressedKeyNumber
D:\System\TEMP\ccYwJ6Mr.s:1144   .text:0000032e checkPressedKeyEvent
D:\System\TEMP\ccYwJ6Mr.s:2438   .bss:00000001 pressed_key.2396
D:\System\TEMP\ccYwJ6Mr.s:1180   .text:00000352 checkReleasedKeyEvent
                             .bss:00000000 released_key.2400
D:\System\TEMP\ccYwJ6Mr.s:1228   .text:0000037a __vector_10
                            *COM*:00000002 timer
                            *COM*:00000001 delay_timer
                            *COM*:00000001 ms_timer
                            *COM*:00000011 stopwatches
                            *COM*:00000001 controlStatus
                            *COM*:00000002 sound_timer
D:\System\TEMP\ccYwJ6Mr.s:1402   .text:000004cc beep
D:\System\TEMP\ccYwJ6Mr.s:1433   .text:000004e8 setBeeperPitch
D:\System\TEMP\ccYwJ6Mr.s:1468   .text:00000506 sleep
D:\System\TEMP\ccYwJ6Mr.s:1498   .text:0000051c mSleep
D:\System\TEMP\ccYwJ6Mr.s:1541   .text:00000536 dischargePeakDetector
D:\System\TEMP\ccYwJ6Mr.s:1566   .text:00000546 getMicrophonePeak
D:\System\TEMP\ccYwJ6Mr.s:1617   .text:00000572 delayCycles
D:\System\TEMP\ccYwJ6Mr.s:1648   .text:0000057c setLCDD
D:\System\TEMP\ccYwJ6Mr.s:1683   .text:0000059e write4BitLCDData
D:\System\TEMP\ccYwJ6Mr.s:1722   .text:000005ba writeLCDCommand
D:\System\TEMP\ccYwJ6Mr.s:1746   .text:000005c8 setCursorPosLCD
D:\System\TEMP\ccYwJ6Mr.s:1775   .text:000005d6 initLCD
D:\System\TEMP\ccYwJ6Mr.s:1869   .text:00000654 clearLCD
D:\System\TEMP\ccYwJ6Mr.s:1891   .text:00000662 writeCharLCD
D:\System\TEMP\ccYwJ6Mr.s:1915   .text:00000670 writeNStringLCD_P
D:\System\TEMP\ccYwJ6Mr.s:1968   .text:0000068e _showScreenLCD_P
D:\System\TEMP\ccYwJ6Mr.s:2038   .text:000006c6 writeStringLCD
D:\System\TEMP\ccYwJ6Mr.s:2081   .text:000006de writeIntegerLCD
                            *COM*:00000011 lcd_tmp_buffer
D:\System\TEMP\ccYwJ6Mr.s:2114   .text:000006f2 writeStringLengthLCD
D:\System\TEMP\ccYwJ6Mr.s:2189   .text:0000072c writeIntegerLengthLCD
D:\System\TEMP\ccYwJ6Mr.s:2312   .text:000007aa clearPosLCD
D:\System\TEMP\ccYwJ6Mr.s:2352   .text:000007c4 initRP6Control

UNDEFINED SYMBOLS
__itoa
__do_copy_data
__do_clear_bss
